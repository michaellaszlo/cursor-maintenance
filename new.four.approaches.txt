
# Maintaining cursor position across formatting operations

How can we format the contents of an input field without displacing the
user's cursor? By formatting we mean any systematic text manipulation,
such as normalizing the textual representation of a number or condensing
whitespace sequences in a document. If the user has placed a cursor
somewhere in the text for navigation or editing purposes, we would like
the cursor to stay in place while the text is modified. Sometimes the
text around the cursor is modified so extensively that it isn't clear
what staying in place is supposed to mean. Even when the cursor's optimal
position is clear to a human observer, it can be tricky to calculate
automatically.

The problem of maintaining cursor position arises in forms with input
fields that check the format of the input text after each keystroke
and reformat the text if the business logic deems it necessary. In many
web implementations, the cursor is moved to the end of the input field
whenever the text is reformatted. This results in a poor experience for
a user who is trying to edit the input value. One keystroke can trigger
a formatting operation that causes the cursor to be abruptly moved
to the end of the string, forcing the user to move the cursor back to
the editing location for the next keystroke. This article explores the
problem in depth and offers several concrete ways to solve it.


## Illustrating the problem

Suppose we're building an input field that expects the user to type in
an integer value. The only characters allowed are digits 0 through 9
and commas. We want the input field to automatically format the text
by separating each group of three digits with a comma, proceeding from
right to left.

Here is a valid input that hasn't been formatted yet:

  13500

After formatting, it looks like this:

  13,500

Now let's consider the cursor. If the input field is initially empty and
the user's first action is to paste in the string "129000", we denote
the state of the input field as follows, with ^ representing the cursor:

  129000^

This is the state immediately after a user-initiated editing
operation, namely the paste action, and before the automatic formatting
operation. The user sees this state momentarily or not at all, because
the input field is quickly updated to show the formatted text.

Where should we put the cursor after the formatting operation? The easy
answer is to place the cursor at the far right of the input field:

  129,000^

It isn't always this easy. Suppose the user moves the cursor leftward by
two characters, positioning it between the first and second zeros. We're
in this state:

  129,0^00

Now the user hits the backspace key:

  129,^00

The text value "129,00" gets formatted to "12,900", and the input field
is updated with the formatted text. Moving the cursor to the far right
of the input field isn't such a hot idea this time, because it makes
the cursor jump over two zeros:

  12,900^

A jumping cursor makes for a poor visual experience and may lead to
further aggravation. If the user intended to backspace over several
characters in a row, she has to manually reposition the cursor:

  12,9^00

It would be better to automatically put the cursor there after the
formatting operation because that's where the user would expect to see
the cursor after backspacing over the leftmost zero digit.

Let's describe the cursor position precisely. When there are i characters
to the left of the cursor, we'll say that the cursor is at position i.

For example, in the text "ant", this is cursor position 0:

  ^ant

This is cursor position 3:

  ant^

Let's manage the cursor position by following a simple rule. If the
cursor is at position i in the text before formatting, we will also put
it at position i in the formatted text.

To repeat the previous example, the cursor is at position 4 immediately
after the user backspaced over the leftmost zero:

  129,^00

After reformatting, we put the cursor at position 4:

  12,9^00

That is exactly where the user expects to see the cursor.

Suppose that the user's next action is to type a '1':

  12,91^00

The cursor is at position 5. The text is formatted and the cursor is
placed at position 5 again:

  129,1^00

Again the rule works.

Now suppose the user types a '9':

  129,19^00

The cursor is at position 6. The text is formatted and the cursor is placed at
position 6:

  1,291,^900

The cursor has jumped over the '9' that the user just typed. It turns out
that our simple rule doesn't work. Keeping the cursor position numerically
constant doesn't always put the cursor where the user expects to see it.


## What can we do?

The problem of cursor maintenance exists because we have automatic
formatting operations that are defined for text, not for text with a
cursor. Text formatting is carried out independently of the cursor:
it takes text as input and returns text as output. The cursor is an
interface widget that we superimpose on the text. In the absence of
automatic formatting, the cursor's movement is strictly determined by the
user's actions. The trouble begins when we add automatic text formatting
and we want to present the illusion that the user remains in control of
the cursor.

Let's be clear about the distinction between the user's edit actions and
the input field's formatting operations. We have an interface that allows
the user to move the cursor around the text. At some location in the
text, the user performs an edit action, which may be a single keystroke
or a mouse-driven action that deletes or inserts a substring of text. We
send the user-edited text to an automatic formatting operation that may
cause the text to be further modified. When we get back the formatted
text, we have to decide where to position the cursor so that the user
isn't surprised.

If that sounds like a fuzzy problem statement, it's because the
problem is inherently fuzzy. To ask where the cursor should be placed
after formatting is to pose a psychological question about user
expectations. There is no hard and fast answer because there are cases
where human observers disagree on cursor placement.

Consider a formatting operation that trims space characters from each end
of the text and reduces internal space sequences to one space each. The
text manipulation is clearly defined, but it's not clear how it should
affect the cursor.

Here is a piece of text prior to formatting, with the cursor surrounded
by spaces:

    'Twas brillig,  and the  slithy ^  toves

Here is the text after formatting, with a provisional cursor placement:

  'Twas brillig, and the slithy^ toves

Is that where the user expects to find the cursor? Perhaps it would feel
more natural to keep the space to the left of the cursor:

  'Twas brillig, and the slithy ^toves

Maybe the cursor should be moved toward whichever non-space character
is closer. What if the cursor is exactly halfway between two non-space
characters? Do we break ties toward the right? Maybe we should always
go right because a predictable interface is desirable.

Because of such ambiguities, there is no definitive strategy for
implementing a cursor maintenance layer on top of text formatting
operations. We are aiming not to eliminate user surprise but to
minimize it.


## Easy cases

Sometimes the correct cursor placement is clear to a human observer. If
the cursor is found among spaces at the beginning or end of the text,
it should be placed at the beginning or end of the trimmed text.

Before formatting:

     Did  gyre  and  gimble  ^

After formatting:

  Did gyre and gimble^

If the cursor is next to a non-space character, it should remain next
to that character across the formatting operation.

Before:

   in  the  ^wabe: 

After:

  in the ^wabe:

How do we resolve such cases automatically? Earlier in this article we
tried a very simple strategy and learned that it was ineffective. Let's
see if we can do better with a slightly more elaborate approach.

We can think of the cursor as splitting the text into two parts, the
one to the left and the one to the right. Why not format the two parts
separately? This would handle cursor placement without ambiguity. Before
and after the formatting operation, the cursor is positioned between
the left and right parts.

Here is some text with a cursor:

    All  mim^sy  were  the borogoves,  

Format the left part:

    All  mim  ->  All mim

Format the right part:

  sy  were  the borogoves,    ->  sy were the borogoves,

Concatenate them at the cursor position:

  All mim^sy were the borogoves,

That was easy. Now for the bad news. This approach is unviable because,
in general, it doesn't make sense to format the left and right parts
separately. It is only guaranteed to work with formatting operations
that consider one character at a time, such as capitalization.

Text with cursor, before capitalization:

  And the^ mome

Left and right parts capitalized:

  And the  ->  AND THE

   mome  ->   MOME

Concatenated:

  AND THE^ MOME

As soon as we have an operation that works on a sequence of characters,
it becomes necessary to preserve continuity between the characters on
each side of the cursor.

Here is a case where we want to apply our space-reducing operation:

   raths ^  outgrabe 

Left and right parts formatted separately:

   raths   ->  raths

    outgrabe   ->  outgrabe

Concatenated:

  raths^outgrabe

To deal with this case correctly, we have to be simultaneously aware of
what lies to the left and to the right of the cursor.

One might argue that the text-splitting approach is almost correct. It
only fails to work for spaces surrounding the cursor. After concatenating
the independently formatted left and right parts, we can examine the one
or two characters in the immediate vicinity of the cursor and adjust them
as necessary. That would indeed work for this operation. It doesn't work
in general.

Recall the number-formatting operation that we described earlier. Consider
this input:

  1234^56789

Left and right parts formatted separately:

  1234  ->  1,234

  56789  ->  56,789

Concatenated:

  1,234^56,789

The result is completely wrong. It doesn't help to inspect a few
characters around the cursor. We have to scan the entirety of the text
to format it correctly:

  123456789  ->  123,456,789

And we have to keep the cursor in its original position:

  123,4^56,789

It remains to be seen what "original position" means and how we can
maintain it.


## Our formatting operations

We will demonstrate various approaches to cursor maintenance using the
two formatting operations that we have already seen.

From now on, we will refer to the numerical formatting operation as
`commatize`. We implement it in Python as follows:

  def commatize(self, s, cursor=None):
      s = s.replace(',', '')
      start = len(s) % 3 or 3
      groups = [ s[:start] ]
      for i in range(start, len(s), 3):
          groups.append(s[i : i + 3])
      s = ','.join(groups)
      return (s, cursor)

As for the formatting operation that trims and condenses space sequences,
we call it `trimify`. Here it is in Python:

  def trimify(self, s, cursor=None):
      s = s.strip()
      s = re.sub('\s+', ' ', s)
      return (s, cursor)

A test runner and a suite of test cases are provided for each operation
in a GitHub repository. The `Formatter` class in approach_examples.py
has the commatize and trimify methods shown here. There is an equivalent
JavaScript file, approach_examples.js, in which `commatize` and `trimify`
are the properties of the `formatter` object.

This is the JavaScript implementation of `commatize`:

  formatter.commatize = function (s, cursor) {
    var start,
        groups,
        i;
    s = s.replace(/,/g, '');
    start = s.length % 3 || 3;
    groups = [ s.substring(0, start) ];
    for (i = start; i < s.length; i += 3) {
      groups.push(s.substring(i, i + 3));
    }
    s = groups.join(',');
    return { text: s, cursor: cursor };
  };

Here is `trimify` in JavaScript:

  formatter.trimify = function (s, cursor) {
    s = s.replace(/^\s+|\s+$/g, '');
    s = s.replace(/\s+/g, ' ');
    return { text: s, cursor: cursor };
  };

In the rest of this article we show only Python code for the sake of
brevity. The GitHub repository contains equivalent JavaScript for every
piece of code shown here.

The implementations above are the baseline versions of `commatize`
and `trimify`. They each take a `cursor` argument denoting the cursor
position and return it as part of the result. They do not modify the
value of `cursor`.

TODO: define "baseline"

The objects that own these methods are interchangeable with other
objects that implement the same text formatting operations and apply
smarter policies for maintaining cursor position. The test runner can
take any of these objects and evaluate its performance on the formatting
operation alone or on the task of maintaining cursor position across
the formatting operation.

For each operation, the test runner contains a list of test cases defining
the cursor-maintenance behavior that we expect to see.

The test cases for `commatize` are the following.

  "2^500" -> "2^,500"
  "125^00" -> "12,5^00"
  "5,4990000^" -> "54,990,000^"
  ",1,^,8,,," -> "1^8"
  "1,0^,0,000" -> "10^0,000"
  "1,^0,000" -> "1^0,000"
  "1,^,000" -> "1^,000"
  "1,^00" -> "1^00"
  "1^234" -> "1^,234"
  "1,0^234" -> "10^,234"
  "10,0^0" -> "1,00^0"

Clearly it's desirable to keep the cursor between the same two digits
before and after the formatting operation. Where controversy may arise
is the decision to place the cursor to the left of the comma in cases
like this:

  "2^500" -> "2^,500"

Some users may prefer to see the cursor to the right of the comma. This
is a subjective matter that we have to decide one way or the other. Our
test suite follows the policy of consistently putting the cursor to the
left whenever the cursor and the comma end up next to each other after
a formatting operation.

It is important to bear in mind that the cursor position chosen by a
cursor-maintenance policy may differ from the user's intention. Therefore,
an input field that employs cursor maintenance should reposition the
cursor only after the text has been modified by an automatic formatting
operation. If the text is unaltered, the input field must not meddle
with the cursor.

Consider a situation in which the user has positioned the cursor to the
right of a comma:

  "2,^500"

The cursor-maintenance policy calls for a different cursor position:

  "2,^500" -> "2^,500"

However, the text is already in the correct format. To avoid interfering
with navigation, the input field must keep the cursor where the user
left it.

The test cases for `trimify` are the following.

  "  hello ^ " -> "hello^"
  " ^ hello  " -> "^hello"
  "Hello, ^ friends." -> "Hello, ^friends."
  "Hello,  ^friends." -> "Hello, ^friends."
  "  whirled^    peas  now  " -> "whirled^ peas now"
  "  whirled ^   peas  now  " -> "whirled ^peas now"
  "  whirled  ^  peas  now  " -> "whirled ^peas now"
  "  whirled   ^ peas  now  " -> "whirled ^peas now"
  "  whirled    ^peas  now  " -> "whirled ^peas now"
  "   ^  " -> "^"

Here we have decided to place the cursor to the right of the space
character whenever the cursor and the space appear side by side in the
formatted text. Again, our policy may not agree with the user's preference
or intention.


## The numerical approach

When an input field applies a small variety of formatting operations, it
is tempting to devise a specific cursor-maintenance algorithm for each
operation. We'll call this the numerical approach because it typically
entails counting characters to calculate a new cursor position. For
`commatize`, we can treat the number of digits to the left of the cursor
as an invariant to be preserved across the formatting operation.

In the following implementation, we count the digit characters to the left
of the cursor before calling the baseline version of `commatize` to format
the text. Then we traverse the formatted text from left to right, counting
digits as we go. Once we have counted the required number of digits,
we set the cursor to the immediate right of the last digit we counted:

    def commatize(self, s, cursor):
        left_digit_count = cursor - s[:cursor].count(',')
        s = Formatter.commatize(self, s)[0]
        if left_digit_count == 0:
            return (s, 0)
        for pos, ch in enumerate(s):
            if ch != ',':
                left_digit_count -= 1
                if left_digit_count == 0:
                    break
        cursor = pos + 1
        return (s, cursor)

By counting digits from left to right and inserting the cursor to the
immediate right of the last counted digit, we ensure that the cursor is
placed to the left of the comma whenever the cursor and comma are found
between the same two digits. What if we wanted to apply the policy that
the cursor should be to the right of the comma whenever the two are
found side by side? Then we could count digits from right to left and
insert the cursor to the immediate left of the last counted digit.

TODO: provide examples

To calculate a new cursor position after `trimify`, we could count the
non-space characters to the left of the cursor and enforce this as an
invariant across the formatting operation. We would have to do additional
work to account for any space characters found adjacent to the cursor.

Instead of counting characters directly, we can let the baseline version
of `trimify` do the work for us. We take the portion of the text lying to
the left of the cursor, append an arbitrary character at its right end,
and call `Formatter.trimify`. This reduces the space sequences to the
left of the cursor.

In most cases, the correct cursor position is one less than the length
of the formatted left portion of the text. The exception is when the
cursor is in the midst of spaces at the right end of the whole text. In
this case, we end up with an extraneous space at the end of the formatted
left portion. We handle it by setting the cursor position to the minimum
of the length of the whole string and the length of the formatted left
portion minus one.

After this reasoning, we end up with a concise Python implementation:

    def trimify(self, s, cursor):
        left_trimmed = Formatter.trimify(self, s[:cursor] + '|')[0]
        s = Formatter.trimify(self, s)[0]
        cursor = min(len(s), len(left_trimmed) - 1)
        return (s, cursor)

The numerical approach, which says that we calculate a new cursor
position according to the mechanics of each formatting operation, does
work. The implementations above conform to the behavior defined by the
test suite. As a general strategy for cursor maintenance, the numerical
approach is weak stuff. In limited scenarios it may be easy enough
to devise ad hoc rules to maintain cursor position. With formatting
operations of greater number and complexity, it becomes burdensome to
work out a specific calculation for each one.


## The textual approach

Let's try out a more systematic approach to maintaining cursor position.
Instead of treating the cursor position as a number, let's incorporate it
into the text as a special character. We'll identify a character that is
not used anywhere in the text and can thus represent the cursor without
ambiguity. We insert this special character into the text at the original
cursor position, carry out the formatting operation, set the new cursor
position to the location of the special character, and finally remove
the special character.

This sounds like a straightforward approach, except it doesn't specify how
we are to format text that includes a special character for the temporary
presence of marking the cursor location. Some formatting operations
may work without modification regardless of the presence of the cursor
character. Others, including `commatize` and `trimify`, require that we
rewrite the formatting operation to work around the cursor character.

To implement `commatize` with a cursor character, we traverse the
original text from right to left, skipping commas and collecting the
other characters in a list. We increment a counter for each digit that
gets added to the list, but not for the cursor character. Whenever
the counter hits three or when we complete our traversal of the text,
we join the list contents into a substring and clear the list. Finally,
the substrings are joined with commas:

    def commatize(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        groups = []
        group_chars = []
        digit_count = 0
        for ch in reversed(s):
            if ch != ',':
                group_chars.append(ch)
                if ch != cursor_char:
                    digit_count += 1
                    if digit_count == 3:
                        groups.append(''.join(reversed(group_chars)))
                        group_chars = []
                        digit_count = 0
        if group_chars != []:
            groups.append(''.join(reversed(group_chars)))
        s = ','.join(reversed(groups))
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)

This cursor-maintaining `commatize` is longer than the one with the
numerical approach because we can't use the baseline `commatize` to
format the text. On the other hand, one might say that this code is
easier to understand because it doesn't require the subtle reasoning of
the numerical approach. It is nearly a pure expression of the formatting
operation.

When it comes to `trimify`, we can take advantage of the baseline
version to format the text because the result will be correct in most
places. `Formatter.trimify` is guaranteed to condense all space sequences
that do not include the cursor character. All that remains is to fix up
the immediate neighborhood of the cursor character.

TODO: provide examples

There can be at most one space on each side of the cursor. If there is
a space on both sides, we delete the one on the right to conform with
our cursor policy. The last cases to consider are the ones in which
the cursor is at the far left or far right of the text. In these cases,
we delete any space character found between the cursor and the text:

    def trimify(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        s = Formatter.trimify(self, s)[0]
        s = s.replace(' ' + cursor_char + ' ', ' ' + cursor_char)
        if s[0] == cursor_char:
            s = s.replace(cursor_char + ' ', cursor_char)
        elif s[-1] == cursor_char:
            s = s.replace(' ' + cursor_char, cursor_char)
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)

The resulting code contains more steps than in the numerical approach,
but the reasoning is no more complicated. Both implementations make use
of the baseline version of `trimify` to do most of the work. The main
difference is that the textual approach makes local adjustments around
the cursor character.

Thus, the textual approach may be especially well suited to maintaining
cursor position in long text. Imagine a document-wide formatting operation
like repagination or reindentation. The textual approach lets us enjoy
the convenience and performance of running the existing formatting
operation. All that remains is to tidy up the formatting around the
cursor character, use the physical position of the cursor character to
set the logical cursor position, and delete the cursor character.


## The meta approach

class TextWithCursor:

    def __init__(self, text='', cursor=0):
        self.text = text
        self.cursor = cursor

    def read(self, begin, length=1):
        return self.text[begin : begin + length]

    def insert(self, begin, subtext):
        self.text = self.text[:begin] + subtext + self.text[begin:]
        if self.cursor > begin:
            self.cursor += len(subtext)

    def delete(self, begin, length=1):
        self.text = self.text[:begin] + self.text[begin + length : ]
        if self.cursor > begin:
            self.cursor -= min(self.cursor - begin, length)

    def length(self):
        return len(self.text)

    def append(self, subtext):
        self.insert(self.length(), subtext)

    def display(self):
        print(self.text)
        print(self.cursor * ' ' + 'â†–')


class MetaCursorFormatter:

    def commatize(self, s, cursor):
        t = TextWithCursor(s, cursor)
        digit_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) == ',':
                t.delete(pos)
            elif digit_count < 2:
                digit_count += 1
            elif pos > 0:
                t.insert(pos, ',')
                digit_count = 0
        return (t.text, t.cursor)

    def trimify(self, s, cursor):
        t = TextWithCursor(s, cursor)
        space_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) != ' ':
                space_count = 0
            elif space_count == 0:
                space_count = 1
            else:
                t.delete(pos + 1)
        for pos in [ t.length() - 1, 0 ]:
            if t.read(pos) == ' ':
                t.delete(pos)
        return (t.text, t.cursor)


## The retrospective approach

def levenshtein(s, t):
    n, m = len(s), len(t)
    if min(n, m) == 0:
        return max(n, m)
    current = list(range(m + 1))
    previous = (m + 1) * [ None ]
    for i in range(1, n + 1):
        current, previous = previous, current
        current[0] = previous[0] + 1
        for j in range(1, m + 1):
            if t[j - 1] == s[i - 1]:
                current[j] = previous[j - 1]
            else:
                current[j] = min(previous[j - 1] + 1,
                                 previous[j] + 1,
                                 current[j - 1] + 1)
    return current[m]

def split_levenshtein(s, s_cursor, t, t_cursor):
    cursor_char = choose_cursor_char(s + t)
    left = levenshtein(s[:s_cursor], t[:t_cursor])
    right = levenshtein(s[s_cursor:], t[t_cursor:])
    return left + right


def get_counts(s, chars):
    counts = { ch: 0 for ch in chars }
    for ch in s:
        if ch in chars:
            counts[ch] += 1
    return counts

def left_right_counts(s, cursor, chars):
    count_left = get_counts(s[:cursor], chars)
    count_right = get_counts(s[cursor:], chars)
    return count_left, count_right

def balance_frequencies(s, s_cursor, t, t_cursor):
    chars = set(list(s)).intersection(set(list(t)))
    s_count_left, s_count_right = left_right_counts(s, s_cursor, chars)
    t_count_left, t_count_right = left_right_counts(t, t_cursor, chars)
    cost = 0
    for ch in chars:
        a = 1.0 * s_count_left[ch] / (s_count_left[ch] + s_count_right[ch])
        b = 1.0 * t_count_left[ch] / (t_count_left[ch] + t_count_right[ch])
        cost += abs(a - b) ** 2
    return cost


class RetrospectiveCursorFormatter(Formatter):

    def __init__(self, get_distance):
        self.get_distance = get_distance

    def adjust_cursor(self, original, cursor, formatting_method):
        formatted = formatting_method(self, original)[0]
        cursor_char = choose_cursor_char(original + formatted)
        get_distance = self.get_distance
        best_cost = get_distance(original, cursor, formatted, 0)
        best_pos = 0
        #print(original[:cursor] + '^' + original[cursor:])
        #print('  ^%s %d' % (formatted, best_cost))
        for pos in range(1, len(formatted) + 1):
            cost = get_distance(original, cursor, formatted, pos) 
            #print('  %s^%s %f' % (formatted[:pos], formatted[pos:], cost))
            if cost < best_cost:
                best_cost = cost
                best_pos = pos
        return (formatted, best_pos)

    def commatize(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.commatize)

    def trimify(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.trimify)


## Lessons learned


Formatting operations are defined for text alone and don't tell us what
to do with the cursor. In some cases the optimal cursor placement is
a subjective matter. We have to make a policy about cursor positioning
that goes beyond the formatting operation. We have to accept the risk
that in some cases, our choice of cursor position will not agree with
the user's expectations.

We can use an all-purpose strategy to guess at a sensible position
for the cursor after an arbitrary formatting operation. Alternatively,
we can define a precise relationship between cursor placement and text
formatting by prescribing a fixed rule for each formatting operation.

given all trouble, is cursor maintenance a good idea at all? yes, it
may be desirable

ad hoc approaches:
  numerical -- not really an approach
  textual -- may be the best solution when formatting large text

systematic approaches:
  meta -- theoretically a drop-in replacement, with caveats
  retrospective -- the simplest approach of all


runnable test scripts in Python and JavaScript

practical web implementation in JavaScript

end-user documentation for everything

