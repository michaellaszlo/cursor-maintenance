
# Maintaining cursor position across formatting operations

How can we format the contents of an input field without perturbing the
user's cursor? By formatting we mean any systematic text manipulation,
such as normalizing the textual representation of a number or condensing
whitespace sequences in a document. If the user has placed a cursor
somewhere in the text for navigation or editing purposes, we would like
the cursor to stay in place while the text is modified. Sometimes the
text around the cursor is modified so extensively that it isn't clear
what staying in place is supposed to mean. Even when the cursor's optimal
position is clear to a human observer, it can be tricky to calculate
automatically.

The problem of maintaining cursor position arises in forms with input
fields that check the format of the input text after each keystroke
and reformat the text if the business logic deems it necessary. In many
web implementations, the cursor is moved to the end of the input field
whenever the text is reformatted. This results in a poor experience for
a user who is trying to edit the input value. One keystroke can trigger
a formatting operation that causes the cursor to be abruptly moved
to the end of the string, forcing the user to move the cursor back to
the editing location for the next keystroke. This article examines the
problem in detail and explores a number of ways to solve it.


## Illustrating the problem

Suppose we're building an input field that expects the user to type in
an integer value. The only characters allowed are digits 0 through 9
and commas. We want the input field to automatically format the text
by separating each group of three digits with a comma, proceeding from
right to left.

Here is a valid input that hasn't been formatted yet:

  13500

After formatting, it looks like this:

  13,500

Now let's consider the cursor. If the input field is initially empty and
the user's first action is to paste in the string "129000", we denote
the state of the input field as follows, with ^ representing the cursor:

  129000^

This is the state immediately after a user-initiated editing
operation, namely the paste action, and before the automatic formatting
operation. The user sees this state momentarily or not at all, because
the input field is quickly updated to show the formatted text.

Where should we put the cursor after the formatting operation? The easy
answer is to place the cursor at the far right of the input field:

  129,000^

It isn't always this easy. Suppose the user moves the cursor leftward by
two characters, positioning it between the first and second zeros. We're
in this state:

  129,0^00

Now the user hits the backspace key:

  129,^00

The text value "129,00" gets formatted to "12,900", and the input field
is updated with the formatted text. Moving the cursor to the far right
of the input field isn't such a hot idea this time, because it makes
the cursor jump over two zeros:

  12,900^

A jumping cursor makes for a poor visual experience and may lead to
further aggravation. If the user intended to backspace over several
characters in a row, she has to manually reposition the cursor:

  12,9^00

It would be better to automatically put the cursor there after the
formatting operation because that's where the user would expect to see
the cursor after backspacing over the leftmost zero digit.

Let's describe the cursor position precisely. When there are i characters
to the left of the cursor, we'll say that the cursor is at position i.

For example, in the text "ant", this is cursor position 0:

  ^ant

This is cursor position 3:

  ant^

Let's manage the cursor position by following a simple rule. If the
cursor is at position i in the text before formatting, we will also put
it at position i in the formatted text.

To repeat the previous example, the cursor is at position 4 immediately
after the user backspaced over the leftmost zero:

  129,^00

After reformatting, we put the cursor at position 4:

  12,9^00

That is exactly where the user expects to see the cursor.

Suppose that the user's next action is to type a '1':

  12,91^00

The cursor is at position 5. The text is formatted and the cursor is
placed at position 5 again:

  129,1^00

Again the rule works.

Now suppose the user types a '9':

  129,19^00

The cursor is at position 6. The text is formatted and the cursor is placed at
position 6:

  1,291,^900

Whoah! The cursor has jumped over the '9' that the user just typed. It
turns out that our simple rule doesn't work. Keeping the cursor position
numerically constant doesn't always put the cursor where the user expects
to see it.


## What can we do?

The root of the problem is that the formatting operation is defined for
text, not for text with a cursor. Formatting is carried out independently
of the cursor: it takes text as input and returns text as output. The
cursor is an interface widget that we superimpose on the text. It works
without a hitch when the user edits the text manually because the cursor's
movement is strictly determined by each user input. It gets tricky when
we carry out automatic text formatting and we want to present the illusion
that the user remains in control of the cursor.

Let's be clear about the distinction between the user's edit actions
and the input field's automatic formatting operations. A user-initiated
edit action can trigger automatic formatting, but these are different
processes. We have an interface that allows the user to move the cursor
around the text. At some location in the text, the user performs an edit
action, which may be a single keystroke or a mouse-driven action that
deletes or inserts a substring of text. We send the user-edited text to
an automatic formatting operation that may cause the text to be further
modified. When we get back the formatted text, we have to decide where
to position the cursor so that the user isn't surprised.

If that sounds like a fuzzy problem statement, it's because the
problem is inherently fuzzy. To ask where the cursor should be placed
after formatting is to pose a psychological question about user
expectations. There is no definitive answer because there are cases
where human observers disagree on what would be the most natural cursor
placement.

Consider a formatting operation that strips space characters from each end
of the text and reduces internal space sequences to one space each. Its
effect on text is clearly defined, but it's unclear how it should affect
the cursor. Here is a piece of text prior to formatting:

    Hello, world.  Hello there.  ^ How are you?  

Here it is after formatting:

  Hello, world. Hello there. ^How are you?

Is that where the user expects to find the cursor? Perhaps it would be
more natural to position it at the end of the preceding sentence:

  Hello, world. Hello there.^ How are you?

Or maybe the cursor should be moved next to whichever sentence is
closer. What if the cursor is exactly halfway between two sentences? Break
ties to the left? Then maybe the cursor should always move left. Or
should it always move right?

However we choose to resolve the matter, it should be clear that we are
making a new rule that goes beyond the text formatting operation. There
is no perfect strategy for implementing a cursor-maintenance layer on
top of formatting operations that are defined for text. We must strike
a compromise in one direction or another. We can apply an all-purpose
strategy that doesn't always put the cursor where the user expects it to.
Alternatively, we can make new rules that go beyond the text formatting
operation by

Because of such ambiguities, we can't hope to eliminate user surprise
entirely. At best we can aim to minimize user surprise.


If we could format the left and right substrings independently,
we wouldn't have a problem. We would format the left, then format the
right, and put the cursor between the two. In general this can't be done.
Many formatting operations, including the ones we've dealt with above,
only make sense when they're applied to the entire string.

For the numerical input

  1234^5678

it wouldn't help to independently format the left part to 1,234 and the
right part to 5,678 because concatenating them yields this incorrectly
formatted string:

  1,234^5,678

We still have the problem of formatting the string as

  12,34^5,678

which requires simultaneous knowledge of what lies to the left of the
cursor and what lies to the right.

Similarly, if we want to remove superfluous spaces from the input

  The quick brown fox  ^  jumps

  149,5^00
  149,50^00 -> 1,495,0^00

  1,495,0^00
  1,^00 -> 1^00


## Commatize and trimify


    test_data = {
        'commatize': [
            ('2500', 1, '2,500', 1),
            ('12500', 3, '12,500', 4),
            ('5,4990000', 9, '54,990,000', 10),
            (',1,,8,,,', 3, '18', 1),
            ('1,0,0,000', 3, '100,000', 2),
            ('1,0,000', 2, '10,000', 1),
            ('1,,000', 2, '1,000', 1),
            ('1,00', 2, '100', 1),
            ('1234', 1, '1,234', 1),
            ('1,0234', 3, '10,234', 2),
            ('10,00', 4, '1,000', 4)
        ],
        'trimify': [
            ('  hello  ', 8, 'hello', 5),
            ('  hello  ', 1, 'hello', 0),
            ('Hello,  friends.', 7, 'Hello, friends.', 7),
            ('Hello,  friends.', 8, 'Hello, friends.', 7),
            ('  whirled    peas  now  ', 9, 'whirled peas now', 7),
            ('  whirled    peas  now  ', 10, 'whirled peas now', 8),
            ('  whirled    peas  now  ', 11, 'whirled peas now', 8),
            ('  whirled    peas  now  ', 12, 'whirled peas now', 8),
            ('  whirled    peas  now  ', 13, 'whirled peas now', 8),
            ('     ', 3, '', 0)
        ]
    }


class Formatter:
    
    def commatize(self, s, cursor=None):
        s = s.replace(',', '')
        start = len(s) % 3 or 3
        groups = [ s[:start] ]
        for i in range(start, len(s), 3):
            groups.append(s[i : i + 3])
        s = ','.join(groups)
        return (s, cursor)

    def trimify(self, s, cursor=None):
        s = s.strip()
        s = re.sub('\s+', ' ', s)
        return (s, cursor)


## Numerical approach

class NumericalCursorFormatter(Formatter):

    def commatize(self, s, cursor):
        left_digit_count = cursor - s[:cursor].count(',')
        s = Formatter.commatize(self, s)[0]
        if left_digit_count == 0:
            return (s, 0)
        for pos, ch in enumerate(s):
            if ch != ',':
                left_digit_count -= 1
                if left_digit_count == 0:
                    break
        cursor = pos + 1
        return (s, cursor)

    def trimify(self, s, cursor):
        left = s[:cursor]
        left_trimmed = Formatter.trimify(self, left + '|')[0]
        left_whitespace_count = cursor - len(left_trimmed) + 1
        s = Formatter.trimify(self, s)[0]
        cursor = min(len(s), cursor - left_whitespace_count)
        return (s, cursor)


def choose_cursor_char(s):
    used_chars = set(list(s))
    for ch in '|^_#':
        if ch not in used_chars:
            return ch
    for code in range(32, 127):
        ch = chr(code)
        if ch not in used_chars:
            return ch
    return None


## Textual approach

class TextualCursorFormatter(Formatter):

    def commatize(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        groups = []
        group_chars = []
        digit_count = 0
        for ch in reversed(s):
            if ch != ',':
                group_chars.append(ch)
                if ch != cursor_char:
                    digit_count += 1
                    if digit_count == 3:
                        groups.append(''.join(reversed(group_chars)))
                        group_chars = []
                        digit_count = 0
        if group_chars != []:
            groups.append(''.join(reversed(group_chars)))
        s = ','.join(reversed(groups))
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)

    def trimify(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        s = Formatter.trimify(self, s)[0]
        s = s.replace(' ' + cursor_char + ' ', ' ' + cursor_char)
        if s[0] == cursor_char:
            s = s.replace(cursor_char + ' ', cursor_char)
        elif s[-1] == cursor_char:
            s = s.replace(' ' + cursor_char, cursor_char)
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)


## Meta approach

class TextWithCursor:

    def __init__(self, text='', cursor=0):
        self.text = text
        self.cursor = cursor

    def read(self, begin, length=1):
        return self.text[begin : begin + length]

    def insert(self, begin, subtext):
        self.text = self.text[:begin] + subtext + self.text[begin:]
        if self.cursor > begin:
            self.cursor += len(subtext)

    def delete(self, begin, length=1):
        self.text = self.text[:begin] + self.text[begin + length : ]
        if self.cursor > begin:
            self.cursor -= min(self.cursor - begin, length)

    def length(self):
        return len(self.text)

    def append(self, subtext):
        self.insert(self.length(), subtext)

    def display(self):
        print(self.text)
        print(self.cursor * ' ' + '↖')


class MetaCursorFormatter:

    def commatize(self, s, cursor):
        t = TextWithCursor(s, cursor)
        digit_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) == ',':
                t.delete(pos)
            elif digit_count < 2:
                digit_count += 1
            elif pos > 0:
                t.insert(pos, ',')
                digit_count = 0
        return (t.text, t.cursor)

    def trimify(self, s, cursor):
        t = TextWithCursor(s, cursor)
        space_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) != ' ':
                space_count = 0
            elif space_count == 0:
                space_count = 1
            else:
                t.delete(pos + 1)
        for pos in [ t.length() - 1, 0 ]:
            if t.read(pos) == ' ':
                t.delete(pos)
        return (t.text, t.cursor)


## Retrospective approach

def levenshtein(s, t):
    n, m = len(s), len(t)
    if min(n, m) == 0:
        return max(n, m)
    current = list(range(m + 1))
    previous = (m + 1) * [ None ]
    for i in range(1, n + 1):
        current, previous = previous, current
        current[0] = previous[0] + 1
        for j in range(1, m + 1):
            if t[j - 1] == s[i - 1]:
                current[j] = previous[j - 1]
            else:
                current[j] = min(previous[j - 1] + 1,
                                 previous[j] + 1,
                                 current[j - 1] + 1)
    return current[m]

def split_levenshtein(s, s_cursor, t, t_cursor):
    cursor_char = choose_cursor_char(s + t)
    left = levenshtein(s[:s_cursor], t[:t_cursor])
    right = levenshtein(s[s_cursor:], t[t_cursor:])
    return left + right


def get_counts(s, chars):
    counts = { ch: 0 for ch in chars }
    for ch in s:
        if ch in chars:
            counts[ch] += 1
    return counts

def left_right_counts(s, cursor, chars):
    count_left = get_counts(s[:cursor], chars)
    count_right = get_counts(s[cursor:], chars)
    return count_left, count_right

def balance_frequencies(s, s_cursor, t, t_cursor):
    chars = set(list(s)).intersection(set(list(t)))
    s_count_left, s_count_right = left_right_counts(s, s_cursor, chars)
    t_count_left, t_count_right = left_right_counts(t, t_cursor, chars)
    cost = 0
    for ch in chars:
        a = 1.0 * s_count_left[ch] / (s_count_left[ch] + s_count_right[ch])
        b = 1.0 * t_count_left[ch] / (t_count_left[ch] + t_count_right[ch])
        cost += abs(a - b) ** 2
    return cost


class RetrospectiveCursorFormatter(Formatter):

    def __init__(self, get_distance):
        self.get_distance = get_distance

    def adjust_cursor(self, original, cursor, formatting_method):
        formatted = formatting_method(self, original)[0]
        cursor_char = choose_cursor_char(original + formatted)
        get_distance = self.get_distance
        best_cost = get_distance(original, cursor, formatted, 0)
        best_pos = 0
        #print(original[:cursor] + '^' + original[cursor:])
        #print('  ^%s %d' % (formatted, best_cost))
        for pos in range(1, len(formatted) + 1):
            cost = get_distance(original, cursor, formatted, pos) 
            #print('  %s^%s %f' % (formatted[:pos], formatted[pos:], cost))
            if cost < best_cost:
                best_cost = cost
                best_pos = pos
        return (formatted, best_pos)

    def commatize(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.commatize)

    def trimify(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.trimify)


## Lessons learned



