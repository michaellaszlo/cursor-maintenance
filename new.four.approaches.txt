
# Maintaining cursor position across formatting operations

How can we format the contents of an input field without displacing the
user's cursor? By formatting we mean any systematic text manipulation,
such as normalizing the textual representation of a number or condensing
whitespace sequences in a document. If the user has placed a cursor
somewhere in the text for navigation or editing purposes, we would like
the cursor to stay in place while the text is modified. Sometimes the
text around the cursor is modified so extensively that it isn't clear
what staying in place is supposed to mean. Even when the cursor's optimal
position is clear to a human observer, it can be tricky to calculate
automatically.

The problem of maintaining cursor position arises in forms with input
fields that check the format of the input text after each keystroke
and reformat the text if the business logic deems it necessary. In many
web implementations, the cursor is moved to the end of the input field
whenever the text is reformatted. This results in a poor experience for
a user who is trying to edit the input value. One keystroke can trigger
a formatting operation that causes the cursor to be abruptly moved
to the end of the string, forcing the user to move the cursor back to
the editing location for the next keystroke. This article explores the
problem in depth and offers several concrete ways to solve it.


## Illustrating the problem

Suppose we're building an input field that expects the user to type in
an integer value. The only characters allowed are digits 0 through 9
and commas. We want the input field to automatically format the text
by separating each group of three digits with a comma, proceeding from
right to left.

Here is a valid input that hasn't been formatted yet:

  13500

After formatting, it looks like this:

  13,500

Now let's consider the cursor. If the input field is initially empty and
the user's first action is to paste in the string "129000", we denote
the state of the input field as follows, with ^ representing the cursor:

  129000^

This is the state immediately after a user-initiated editing
operation, namely the paste action, and before the automatic formatting
operation. The user sees this state momentarily or not at all, because
the input field is quickly updated to show the formatted text.

Where should we put the cursor after the formatting operation? The easy
answer is to place the cursor at the far right of the input field:

  129,000^

It isn't always this easy. Suppose the user moves the cursor leftward by
two characters, positioning it between the first and second zeros. We're
in this state:

  129,0^00

Now the user hits the backspace key:

  129,^00

The text value "129,00" gets formatted to "12,900", and the input field
is updated with the formatted text. Moving the cursor to the far right
of the input field isn't such a hot idea this time, because it makes
the cursor jump over two zeros:

  12,900^

A jumping cursor makes for a poor visual experience and may lead to
further aggravation. If the user intended to backspace over several
characters in a row, she has to manually reposition the cursor:

  12,9^00

It would be better to automatically put the cursor there after the
formatting operation because that's where the user would expect to see
the cursor after backspacing over the leftmost zero digit.

Let's describe the cursor position precisely. When there are i characters
to the left of the cursor, we'll say that the cursor is at position i.

For example, in the text "ant", this is cursor position 0:

  ^ant

This is cursor position 3:

  ant^

Let's manage the cursor position by following a simple rule. If the
cursor is at position i in the text before formatting, we will also put
it at position i in the formatted text.

To repeat the previous example, the cursor is at position 4 immediately
after the user backspaced over the leftmost zero:

  129,^00

After reformatting, we put the cursor at position 4:

  12,9^00

That is exactly where the user expects to see the cursor.

Suppose that the user's next action is to type a '1':

  12,91^00

The cursor is at position 5. The text is formatted and the cursor is
placed at position 5 again:

  129,1^00

Again the rule works.

Now suppose the user types a '9':

  129,19^00

The cursor is at position 6. The text is formatted and the cursor is placed at
position 6:

  1,291,^900

The cursor has jumped over the '9' that the user just typed. It turns out
that our simple rule doesn't work. Keeping the cursor position numerically
constant doesn't always put the cursor where the user expects to see it.


## What can we do?

The problem of cursor maintenance exists because we have automatic
formatting operations that are defined for text, not for text with a
cursor. Text formatting is carried out independently of the cursor:
it takes text as input and returns text as output. The cursor is an
interface widget that we superimpose on the text. In the absence of
automatic formatting, the cursor's movement is strictly determined by the
user's actions. The trouble begins when we add automatic text formatting
and we want to present the illusion that the user remains in control of
the cursor.

Let's be clear about the distinction between the user's edit actions and
the input field's formatting operations. We have an interface that allows
the user to move the cursor around the text. At some location in the
text, the user performs an edit action, which may be a single keystroke
or a mouse-driven action that deletes or inserts a substring of text. We
send the user-edited text to an automatic formatting operation that may
cause the text to be further modified. When we get back the formatted
text, we have to decide where to position the cursor so that the user
isn't surprised.

If that sounds like a fuzzy problem statement, it's because the
problem is inherently fuzzy. To ask where the cursor should be placed
after formatting is to pose a psychological question about user
expectations. There is no hard and fast answer because there are cases
where human observers disagree on cursor placement.

Consider a formatting operation that trims space characters from each end
of the text and reduces internal space sequences to one space each. The
text manipulation is clearly defined, but it's not clear how it should
affect the cursor.

Here is a piece of text prior to formatting, with the cursor surrounded
by spaces:

    'Twas brillig,  and the  slithy ^  toves

Here is the text after formatting, with a provisional cursor placement:

  'Twas brillig, and the slithy^ toves

Is that where the user expects to find the cursor? Perhaps it would feel
more natural to keep the space to the left of the cursor:

  'Twas brillig, and the slithy ^toves

Maybe the cursor should be moved toward whichever non-space character
is closer. What if the cursor is exactly halfway between two non-space
characters? Do we break ties toward the right? Maybe we should always
go right because a predictable interface is desirable.

Because of such ambiguities, there is no definitive strategy for
implementing a cursor maintenance layer on top of text formatting
operations. We are aiming not to eliminate user surprise but to
minimize it.

TODO: describe the bifurcated question
- what is a good policy for deciding ambiguous cursor placement?
- if an arbitrary policy is prescribed, how do we comply with it?


## Easy cases

Sometimes the correct cursor placement is clear to a human observer. If
the cursor is found among spaces at the beginning or end of the text,
it should be placed at the beginning or end of the trimmed text.

Before formatting:

     Did  gyre  and  gimble  ^

After formatting:

  Did gyre and gimble^

If the cursor is next to a non-space character, it should remain next
to that character across the formatting operation.

Before:

   in  the  ^wabe: 

After:

  in the ^wabe:

How do we resolve such cases automatically? Earlier in this article we
tried a very simple strategy and learned that it was ineffective. Let's
see if we can do better with a slightly more elaborate approach.

We can think of the cursor as splitting the text into two parts, the
one to the left and the one to the right. Why not format the two parts
separately? This would handle cursor placement without ambiguity. Before
and after the formatting operation, the cursor is positioned between
the left and right parts.

Here is some text with a cursor:

    All  mim^sy  were  the borogoves,  

Format the left part:

    All  mim  ->  All mim

Format the right part:

  sy  were  the borogoves,    ->  sy were the borogoves,

Concatenate them at the cursor position:

  All mim^sy were the borogoves,

That was easy. Now for the bad news. This approach is unviable because,
in general, it doesn't make sense to format the left and right parts
separately. It is only guaranteed to work with formatting operations
that consider one character at a time, such as capitalization.

Text with cursor, before capitalization:

  And the^ mome

Left and right parts capitalized:

  And the  ->  AND THE

   mome  ->   MOME

Concatenated:

  AND THE^ MOME

As soon as we have an operation that works on a sequence of characters,
it becomes necessary to preserve continuity between the characters on
each side of the cursor.

Here is a case where we want to apply our space-reducing operation:

   raths ^  outgrabe 

Left and right parts formatted separately:

   raths   ->  raths

    outgrabe   ->  outgrabe

Concatenated:

  raths^outgrabe

To deal with this case correctly, we have to be simultaneously aware of
what lies to the left and to the right of the cursor.

One might argue that the text-splitting approach is almost correct. It
only fails to work for spaces surrounding the cursor. After concatenating
the independently formatted left and right parts, we can examine the
one or two characters in the vicinity of the cursor and adjust them as
necessary. That would indeed work for this operation. It doesn't work
in general.

Recall the number-formatting operation that we described earlier. Consider
this input:

  1234^56789

Left and right parts formatted separately:

  1234  ->  1,234

  56789  ->  56,789

Concatenated:

  1,234^56,789

The result is completely wrong. It doesn't help to inspect a few
characters around the cursor. We have to scan the entirety of the text
to format it correctly:

  123456789  ->  123,456,789

And we have to keep the cursor in its original position:

  123,4^56,789

It remains to be seen what "original position" means and how we can
maintain it.


## Our formatting operations

We will demonstrate various approaches to cursor maintenance using the
two formatting operations that we have already introduced.

From now on, we will refer to the numerical formatting operation as
`commatize`. We implement it in Python as follows:

  def commatize(self, s, cursor=None):
      s = s.replace(',', '')
      start = len(s) % 3 or 3
      groups = [ s[:start] ]
      for i in range(start, len(s), 3):
          groups.append(s[i : i + 3])
      s = ','.join(groups)
      return (s, cursor)

As for the formatting operation that trims and condenses space sequences,
we call it `trimify`. Here it is in Python:

  def trimify(self, s, cursor=None):
      s = s.strip()
      s = re.sub('\s+', ' ', s)
      return (s, cursor)

A test runner and a suite of test cases are provided for each operation
in a GitHub repository. The `Formatter` class in approach_examples.py
has the commatize and trimify methods shown here. There is an equivalent
JavaScript file, approach_examples.js, in which `commatize` and `trimify`
are the properties of the `formatter` object.

This is the JavaScript implementation of `commatize`:

  formatter.commatize = function (s, cursor) {
    var start,
        groups,
        i;
    s = s.replace(/,/g, '');
    start = s.length % 3 || 3;
    groups = [ s.substring(0, start) ];
    for (i = start; i < s.length; i += 3) {
      groups.push(s.substring(i, i + 3));
    }
    s = groups.join(',');
    return { text: s, cursor: cursor };
  };

Here is `trimify` in JavaScript:

  formatter.trimify = function (s, cursor) {
    s = s.replace(/^\s+|\s+$/g, '');
    s = s.replace(/\s+/g, ' ');
    return { text: s, cursor: cursor };
  };

In the rest of this article we show only Python code for the sake of
brevity. The GitHub repository contains equivalent JavaScript for every
piece of code shown here.

The implementations above are the baseline versions of `commatize`
and `trimify`. They each take a `cursor` argument denoting the cursor
position and return it as part of the result. They do not modify the
value of `cursor`.

TODO: define "baseline"

The objects that own these methods are interchangeable with other
objects that implement the same text formatting operations and apply
smarter policies for maintaining cursor position. The test runner can
take any of these objects and evaluate its performance on the formatting
operation alone or on the task of maintaining cursor position across
the formatting operation.

For each operation, the test runner contains a list of test cases defining
the cursor-maintenance behavior that we expect to see.

The test cases for `commatize` are the following.

  "2^500" -> "2^,500"
  "125^00" -> "12,5^00"
  "5,4990000^" -> "54,990,000^"
  ",1,^,8,,," -> "1^8"
  "1,0^,0,000" -> "10^0,000"
  "1,^0,000" -> "1^0,000"
  "1,^,000" -> "1^,000"
  "1,^00" -> "1^00"
  "1^234" -> "1^,234"
  "1,0^234" -> "10^,234"
  "10,0^0" -> "1,00^0"

Clearly it's desirable to keep the cursor between the same two digits
before and after the formatting operation. Where controversy may arise
is the decision to place the cursor to the left of the comma in cases
like this:

  "2^500" -> "2^,500"

Some users may prefer to see the cursor to the right of the comma. This
is a subjective matter that we have to decide one way or the other. Our
test suite follows the policy of consistently putting the cursor to the
left whenever the cursor and the comma end up next to each other after
a formatting operation.

It is important to bear in mind that the cursor position chosen by a
cursor-maintenance policy may differ from the user's intention. Therefore,
an input field that employs cursor maintenance should reposition the
cursor only after the text has been modified by an automatic formatting
operation. If the text is unaltered, the input field must not meddle
with the cursor.

Consider a situation in which the user has positioned the cursor to the
right of a comma:

  "2,^500"

The cursor-maintenance policy calls for a different cursor position:

  "2,^500" -> "2^,500"

However, the text is already in the correct format. To avoid interfering
with navigation, the input field must keep the cursor where the user
left it.

The test cases for `trimify` are the following.

  "  hello ^ " -> "hello^"
  " ^ hello  " -> "^hello"
  "Hello, ^ friends." -> "Hello, ^friends."
  "Hello,  ^friends." -> "Hello, ^friends."
  "  whirled^    peas  now  " -> "whirled^ peas now"
  "  whirled ^   peas  now  " -> "whirled ^peas now"
  "  whirled  ^  peas  now  " -> "whirled ^peas now"
  "  whirled   ^ peas  now  " -> "whirled ^peas now"
  "  whirled    ^peas  now  " -> "whirled ^peas now"
  "   ^  " -> "^"

Here we have decided to place the cursor to the right of the space
character whenever the cursor and the space appear side by side in the
formatted text. Again, our policy may not agree with the user's preference
or intention.


## The numerical approach

When an input field applies a small variety of formatting operations, it
is tempting to devise a specific cursor-maintenance algorithm for each
operation. We'll call this the numerical approach because it typically
entails counting characters to calculate a new cursor position. For
`commatize`, we can treat the number of digits to the left of the cursor
as an invariant to be preserved across the formatting operation.

In the following implementation, we count the digit characters to the left
of the cursor before calling the baseline version of `commatize` to format
the text. Then we traverse the formatted text from left to right, counting
digits as we go. Once we have counted the required number of digits,
we set the cursor to the immediate right of the last digit we counted:

    def commatize(self, s, cursor):
        left_digit_count = cursor - s[:cursor].count(',')
        s = Formatter.commatize(self, s)[0]
        if left_digit_count == 0:
            return (s, 0)
        for pos, ch in enumerate(s):
            if ch != ',':
                left_digit_count -= 1
                if left_digit_count == 0:
                    break
        cursor = pos + 1
        return (s, cursor)

By counting digits from left to right and inserting the cursor to the
immediate right of the last counted digit, we ensure that the cursor is
placed to the left of the comma whenever the cursor and comma are found
between the same two digits. What if we wanted to apply the policy that
the cursor should be to the right of the comma whenever the two are
found side by side? Then we could count digits from right to left and
insert the cursor to the immediate left of the last counted digit.

TODO: provide examples

To calculate a new cursor position after `trimify`, we could count the
non-space characters to the left of the cursor and enforce this as an
invariant across the formatting operation. We would have to do additional
work to account for any space characters found adjacent to the cursor.

Instead of counting characters directly, we can let the baseline version
of `trimify` do the work for us. We take the portion of the text lying to
the left of the cursor, append an arbitrary character at its right end,
and call `Formatter.trimify`. This reduces the space sequences to the
left of the cursor.

In most cases, the correct cursor position is one less than the length
of the formatted left portion of the text. The exception is when the
cursor is in the midst of spaces at the right end of the whole text. In
this case, we end up with an extraneous space at the end of the formatted
left portion. We handle it by setting the cursor position to the minimum
of the length of the whole string and the length of the formatted left
portion minus one.

After this reasoning, we end up with a concise Python implementation:

    def trimify(self, s, cursor):
        left_trimmed = Formatter.trimify(self, s[:cursor] + '|')[0]
        s = Formatter.trimify(self, s)[0]
        cursor = min(len(s), len(left_trimmed) - 1)
        return (s, cursor)

The numerical approach, which says that we calculate a new cursor
position according to the mechanics of each formatting operation, does
work. The implementations above conform to the behavior defined by the
test suite. As a general strategy for cursor maintenance, the numerical
approach is weak stuff. In limited scenarios it may be easy enough
to devise ad hoc rules to maintain cursor position. With formatting
operations of greater number and complexity, it becomes burdensome to
work out a specific calculation for each one.


## The textual approach

Let's try out a more systematic approach to maintaining cursor position.
Instead of treating the cursor position as a number, let's incorporate
it into the text as a special character. We'll identify a character
that is not used anywhere in the text and can thus represent the cursor
without ambiguity. We insert this special character into the text at the
original cursor position, carry out the formatting operation, and set the
new cursor position to the location of the special character. Finally,
we delete the special character because it was only a marker for the
logical cursor position.

This sounds like a straightforward approach, except it doesn't specify
how we are to format text that includes a special character which will be
deleted before we return the text to the user. Some formatting operations
may work without modification regardless of the presence of the cursor
character. Others, including `commatize` and `trimify`, require that we
rewrite the formatting operation to work around the cursor character.

To implement `commatize` with a cursor character, we traverse the
original text from right to left, skipping commas and collecting the
other characters in a list. We increment a counter for each digit that
gets added to the list, but not for the cursor character. Whenever
the counter hits three or when we complete our traversal of the text,
we join the list contents into a substring and clear the list. Finally,
the substrings are joined with commas:

    def commatize(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        groups = []
        group_chars = []
        digit_count = 0
        for ch in reversed(s):
            if ch != ',':
                group_chars.append(ch)
                if ch != cursor_char:
                    digit_count += 1
                    if digit_count == 3:
                        groups.append(''.join(reversed(group_chars)))
                        group_chars = []
                        digit_count = 0
        if group_chars != []:
            groups.append(''.join(reversed(group_chars)))
        s = ','.join(reversed(groups))
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)

This cursor-maintaining `commatize` is longer than the one with the
numerical approach because we can't use the baseline `commatize` to
format the text. On the other hand, one might say that this code is
easier to understand because it doesn't require the subtle reasoning of
the numerical approach. It is nearly a pure expression of the formatting
operation.

When it comes to `trimify`, we can take advantage of the baseline
version to format the text because the result will be correct in most
places. `Formatter.trimify` is guaranteed to condense all space sequences
that do not include the cursor character. All that remains is to tinker
with the immediate neighborhood of the cursor character.

TODO: provide examples

There can be at most one space on each side of the cursor. If there is
a space on both sides, we delete the one on the right to conform with
our cursor policy. The last cases to consider are the ones in which
the cursor is at the far left or far right of the text. In these cases,
we delete any space character found between the cursor and the text:

    def trimify(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        s = Formatter.trimify(self, s)[0]
        s = s.replace(' ' + cursor_char + ' ', ' ' + cursor_char)
        if s[0] == cursor_char:
            s = s.replace(cursor_char + ' ', cursor_char)
        elif s[-1] == cursor_char:
            s = s.replace(' ' + cursor_char, cursor_char)
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)

The resulting code contains more steps than in the numerical approach,
but the reasoning is no more complicated. Both implementations make use
of the baseline version of `trimify` to do most of the work. The main
difference is that the textual approach makes local adjustments around
the cursor character.

Thus, the textual approach may be especially well suited to maintaining
cursor position in long text. Imagine a document-wide formatting operation
like repagination or reindentation. We insert one character at the cursor
position to serve as a proxy for the logical cursor. The textual approach
lets us enjoy the convenience and performance of running the existing
formatting operation. Afterward we tidy up the formatting around the
cursor character, use the cursor character's position to set the logical
cursor position, and delete the cursor character.


## The meta approach

Each of our efforts thus far to maintain cursor position has been
a kludge. The numerical approach deals with the text and the cursor
as separate values which it tries to synchronize by means of ad hoc
calculations. The textual approach incorporates the cursor into the text
and massages the characters around the cursor. These are haphazard ways
of dealing with the true nature of cursor maintenance. The truth is that
some operations on text affect the position of the cursor and some don't.

Let us enumerate the cases. An operation that inserts text to the right of
the cursor does not affect the cursor position. An operation that inserts
text to the left of the cursor increases the cursor position by the number
of characters that were inserted. Similar statements apply to deletion:
an operation that deletes text to the right of the cursor does not affect
the cursor position, and an operation that deletes text to the left of
the cursor reduces the cursor position by the number of characters that
were deleted. The only remaining case is the one in which an operation
deletes text that includes the cursor. In this case, the cursor position
decreases by the number of characters that are deleted to the left of it.

TODO: provide examples

If these are the essential facts of cursor maintenance, we can stop
dancing around them. We can confront them squarely by implementing
the formatting operations on a new data type that reflects these
facts. Instead of operating on a string that contains the text and
separately manipulating an integer value that contains the cursor
position, we will operate on an object that simultaneously contains
the text and the cursor position. For each operation that we perform,
the object will update the text and the cursor. Thus, we never have to
fiddle with the cursor ourselves. The text-with-cursor object takes care
of maintaining cursor position.

What are the elementary operations that the text-with-cursor data type
must offer so that we can perform any formatting operation? Hitherto
we have employed a variety of string operations, including substring
replacement and regular-expression matching. All of these can be
implemented using four elementary operations.

- read
- insert
- delete
- length

The `read` operation reads one or more characters starting from a
given position in the text. The `insert` operation inserts one or
more characters at a given position. The `delete` operation deletes
one or more characters starting from a given position. The `length`
operation returns the length of the text so that we know what text
positions are valid, letting us do things like traverse the text from
left to right. In theory it would suffice to offer operations that read,
insert, and delete one character at a time. We allow several characters
at a time as a convenience.

In addition to the text operations, we require a method to set the cursor
position and another to read the cursor position. These allow us to move
the cursor in response to user input and to update the user interface
after a formatting operation has been performed.

The following Python class implements the text-with-cursor data type
sufficiently for experimental purposes. The `begin` and `length`
arguments are used without validation. There are no getter and setter
methods for cursor position because Python lets us access the `cursor`
property directly.

class TextWithCursor:

    def __init__(self, text='', cursor=0):
        self.text = text
        self.cursor = cursor

    def read(self, begin, length=1):
        return self.text[begin : begin + length]

    def insert(self, begin, subtext):
        self.text = self.text[:begin] + subtext + self.text[begin:]
        if self.cursor > begin:
            self.cursor += len(subtext)

    def delete(self, begin, length=1):
        self.text = self.text[:begin] + self.text[begin + length : ]
        if self.cursor > begin:
            self.cursor -= min(self.cursor - begin, length)

    def length(self):
        return len(self.text)

Now we can implement `commatize` in a straightforward fashion. We
traverse the text from right to left, counting digits and inserting a
comma to the left of every third one, while deleting all other commas. The
following implementation makes no mention of the cursor except when the
`TextWithCursor` object is instantiated and when the `cursor` property
is consulted at the end of the function.

    def commatize(self, s, cursor):
        t = TextWithCursor(s, cursor)
        digit_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) == ',':
                t.delete(pos)
            elif digit_count < 2:
                digit_count += 1
            elif pos > 0:
                t.insert(pos, ',')
                digit_count = 0
        return (t.text, t.cursor)

We are using `TextWithCursor` as a temporary cursor manager in order
to make this function compatible with the other functions in our
comparison. In a more practical implementation, we would maintain a
persistent `TextWithCursor` object.

The `trimify` implementation traverses the text from right to left,
deleting all but the rightmost space in each sequence of spaces. This
leaves at most one space at the far left and far right of the text. We
check for these and delete each one if it exists.

    def trimify(self, s, cursor):
        t = TextWithCursor(s, cursor)
        space_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) != ' ':
                space_count = 0
            elif space_count == 0:
                space_count = 1
            else:
                t.delete(pos + 1)
        for pos in [ t.length() - 1, 0 ]:
            if t.read(pos) == ' ':
                t.delete(pos)
        return (t.text, t.cursor)

This implementation of `trimify` is straightforward except for the
subtleties that arise when the cursor is in the middle of a space
sequence prior to formatting. In other words, we're considering cases
in which there is a space character to the left and to the right of the
cursor. The direction of traversal and deletion determines what happens
in these cases. Going from right to left, deleting all but the rightmost
space in each sequence of spaces, has the effect of pushing the cursor
to the left end of the space sequence. This is the behavior specified
by the formatting operation. We noted earlier that this was an arbitrary
choice in the specification. If the `trimify` formatting operation were
defined with the opposite choice, decreeing that the cursor should be
pushed to the right end of a space sequence, we would want to traverse
the text from left to right as we delete extraneous spaces.

Thus, even though the `TextWithCursor` object relieves us of the
bookkeeping duties of maintaining cursor position, we cannot be
oblivious to the effects of text operations on the cursor. Suppose we
have formulated an abstract definition of each formatting operation
that specifies the exact behavior of the cursor. In implementing the
formatting operation, we must use the `delete` and `insert` operations
in such a way that the underlying cursor movements will result in the
specified behavior.

To look at the problem from another angle, consider the formatting
operations as they were originally implemented with ordinary strings, in
complete ignorance of the cursor. Suppose we were to use this code as is,
except that the strings were replaced with `TextWithCursor` objects. This
requires that we do additional work to implement a `TextWithCursor`
equivalent for each string operation. In the particular case of our
`commatize` and `stringify` implementations, we would have to write
new versions of `str.replace`, `str.join`, `str.strip`, and `re.sub`
that work with `TextWithCursor` objects instead of plain strings. All
of these can be expressed in terms of the four elementary operations we
described above.

After doing all this work, consider what would happen to the cursor. Would
it move in the way we expect it to? That depends on what we expect. Take
this crucial line in the `trimify` function:

      s = re.sub('\s+', ' ', s)

If our expectation is that the `re.sub` string operation is implemented
by deleting the matching substring and then inserting the replacement
string, and that the cursor is affected in exactly the way that we
have defined for the elementary deletion and insertion operations on
`TextWithCursor`, then the cursor will behave as we expect.

In other words, we can use `TextWithCursor` as a drop-in replacement
for strings as long as we say that the resulting cursor behavior is the
correct behavior. This tautological proviso may be seen as a liability. It
can also be viewed as an advantage because it gives us a comprehensive
strategy to the question of cursor behavior. If we choose to abide by it,
all ambiguities of cursor placement are resolved by fiat.


## The retrospective approach

The numerical approach and textual approach require us to write a new
implementation for each formatting operation. The meta approach preserves
the existing code for the formatting operations, at the cost of writing an
equivalent text-with-cursor method for each string method. Can we avoid
all of this work by staying in the realm of plain strings, yet keeping
the formatting operations as they are? Consider how we might proceed if
we carry out a formatting operation and try to find a reasonable cursor
position afterward. We make no attempt to analyze the workings of the
formatting operation. We treat it as a black box.

Before formatting, we have the original text and the original cursor
position. We feed the text into the formatting operation, which emits
the formatted text. Now we want to calculate a new cursor position. To
do so, we compare the original text to the formatted text. Where should
we place the cursor in the formatted text so that its position is most
similar to the cursor's position in the original text?

Among the various ways to answer this question is the notion of edit
distance. Generally speaking, the edit distance from a string A to a
string B is the cost of transforming A into B by applying elementary
string operations. There are many possible measures of edit distance. One
well-known measure is the Levenshtein distance, which stipulates three
elementary string operations: inserting a character, deleting a character,
or replacing (overwriting) a character. Each operation has unit cost
per application. Thus, the Levenshtein distance is the minimum number
of insertions, deletions, and replacements that transform string A into
string B.


def levenshtein(s, t):
    n, m = len(s), len(t)
    if min(n, m) == 0:
        return max(n, m)
    current = list(range(m + 1))
    previous = (m + 1) * [ None ]
    for i in range(1, n + 1):
        current, previous = previous, current
        current[0] = previous[0] + 1
        for j in range(1, m + 1):
            if t[j - 1] == s[i - 1]:
                current[j] = previous[j - 1]
            else:
                current[j] = min(previous[j - 1] + 1,
                                 previous[j] + 1,
                                 current[j - 1] + 1)
    return current[m]

def split_levenshtein(s, s_cursor, t, t_cursor):
    cursor_char = choose_cursor_char(s + t)
    left = levenshtein(s[:s_cursor], t[:t_cursor])
    right = levenshtein(s[s_cursor:], t[t_cursor:])
    return left + right


def get_counts(s, chars):
    counts = { ch: 0 for ch in chars }
    for ch in s:
        if ch in chars:
            counts[ch] += 1
    return counts

def left_right_counts(s, cursor, chars):
    count_left = get_counts(s[:cursor], chars)
    count_right = get_counts(s[cursor:], chars)
    return count_left, count_right

def balance_frequencies(s, s_cursor, t, t_cursor):
    chars = set(list(s)).intersection(set(list(t)))
    s_count_left, s_count_right = left_right_counts(s, s_cursor, chars)
    t_count_left, t_count_right = left_right_counts(t, t_cursor, chars)
    cost = 0
    for ch in chars:
        a = 1.0 * s_count_left[ch] / (s_count_left[ch] + s_count_right[ch])
        b = 1.0 * t_count_left[ch] / (t_count_left[ch] + t_count_right[ch])
        cost += abs(a - b) ** 2
    return cost


class RetrospectiveCursorFormatter(Formatter):

    def __init__(self, get_distance):
        self.get_distance = get_distance

    def adjust_cursor(self, original, cursor, formatting_method):
        formatted = formatting_method(self, original)[0]
        cursor_char = choose_cursor_char(original + formatted)
        get_distance = self.get_distance
        best_cost = get_distance(original, cursor, formatted, 0)
        best_pos = 0
        for pos in range(1, len(formatted) + 1):
            cost = get_distance(original, cursor, formatted, pos) 
            if cost < best_cost:
                best_cost = cost
                best_pos = pos
        return (formatted, best_pos)

    def commatize(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.commatize)

    def trimify(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.trimify)


## Lessons learned


Formatting operations are defined for text alone and don't tell us what
to do with the cursor. In some cases the optimal cursor placement is
a subjective matter. We have to make a policy about cursor positioning
that goes beyond the formatting operation. We have to accept the risk
that in some cases, our choice of cursor position will not agree with
the user's expectations.

We can use an all-purpose strategy to guess at a sensible position
for the cursor after an arbitrary formatting operation. Alternatively,
we can define a precise relationship between cursor placement and text
formatting by prescribing a fixed rule for each formatting operation.

given all trouble, is cursor maintenance a good idea at all? yes, it
may be desirable

ad hoc approaches:
  numerical -- not really an approach
  textual -- may be the best solution when formatting large text

systematic approaches:
  meta -- theoretically a drop-in replacement for strings, with caveats
  retrospective -- the simplest approach of all


runnable test scripts in Python and JavaScript

practical web implementation in JavaScript

end-user documentation for everything

