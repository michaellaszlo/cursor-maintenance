
# Maintaining cursor position across formatting operations

How can we format the contents of an input field without displacing the
user's cursor? By formatting we mean any systematic text manipulation,
such as normalizing the textual representation of a number or condensing
whitespace sequences in a document. If the user has placed a cursor
somewhere in the text for navigation or editing purposes, we would like
the cursor to stay in place while the text is modified. Sometimes the
text around the cursor is modified so extensively that it isn't clear
what staying in place is supposed to mean. Even when the cursor's optimal
position is clear to a human observer, it can be tricky to calculate
automatically.

The problem of maintaining cursor position arises in forms with input
fields that check the format of the input text after each keystroke
and reformat the text if the business logic deems it necessary. In many
web implementations, the cursor is moved to the end of the input field
whenever the text is reformatted. This results in a poor experience for
a user who is trying to edit the input value. One keystroke can trigger
a formatting operation that causes the cursor to be abruptly moved
to the end of the string, forcing the user to move the cursor back to
the editing location for the next keystroke. This article explores the
problem in depth and offers several concrete ways to solve it.


## First signs of trouble

Suppose we're building an input field that expects the user to type in
an integer value. The only characters allowed are digits 0 through 9
and commas. We want the input field to automatically format the text
by separating each group of three digits with a comma, proceeding from
right to left.

Here is a valid input that hasn't been formatted yet:

  13500

After formatting, it looks like this:

  13,500

Now let's consider the cursor. If the input field is initially empty and
the user's first action is to paste in the string "129000", we denote
the state of the input field as follows, with ^ representing the cursor:

  129000^

This is the state immediately after a user-initiated editing
operation, namely the paste action, and before the automatic formatting
operation. The user sees this state momentarily or not at all, because
the input field is quickly updated to show the formatted text.

Where should we put the cursor after the formatting operation? The easy
answer is to place the cursor at the far right of the input field:

  129,000^

It isn't always this easy. Suppose the user moves the cursor leftward by
two characters, positioning it between the first and second zeros. We're
in this state:

  129,0^00

Now the user hits the backspace key:

  129,^00

The text value "129,00" gets formatted to "12,900", and the input field
is updated with the formatted text. Moving the cursor to the far right
of the input field isn't such a hot idea this time, because it makes
the cursor jump over two zeros:

  12,900^

A jumping cursor makes for a poor visual experience and may lead to
further aggravation. If the user intended to backspace over several
characters in a row, she has to manually reposition the cursor:

  12,9^00

It would be better to automatically put the cursor there after the
formatting operation because that's where the user would expect to see
the cursor after backspacing over the leftmost zero digit.

Let's describe the cursor position precisely. When there are i characters
to the left of the cursor, we'll say that the cursor is at position i.

For example, in the text "ant", this is cursor position 0:

  ^ant

This is cursor position 3:

  ant^

Let's manage the cursor position by following a simple rule. If the
cursor is at position i in the text before formatting, we will also put
it at position i in the formatted text.

To repeat the previous example, the cursor is at position 4 immediately
after the user backspaced over the leftmost zero:

  129,^00

After reformatting, we put the cursor at position 4:

  12,9^00

That is exactly where the user expects to see the cursor.

Suppose that the user's next action is to type a '1':

  12,91^00

The cursor is at position 5. The text is formatted and the cursor is
placed at position 5 again:

  129,1^00

Again the rule works.

Now suppose the user types a '9':

  129,19^00

The cursor is at position 6. The text is formatted and the cursor is placed at
position 6:

  1,291,^900

The cursor has jumped over the '9' that the user just typed. It turns out
that our simple rule doesn't work. Keeping the cursor position numerically
constant doesn't always put the cursor where the user expects to see it.


## The nature of the beast

The problem of cursor maintenance exists because we have automatic
formatting operations that are defined for text, not for text with a
cursor. Text formatting is carried out independently of the cursor:
it takes text as input and returns text as output. The cursor is an
interface widget that we superimpose on the text. In the absence of
automatic formatting, the cursor's movement is strictly determined by the
user's actions. The trouble begins when we add automatic text formatting
and we want to present the illusion that the user remains in control of
the cursor.

Let's be clear about the distinction between the user's edit actions and
the input field's formatting operations. We have an interface that allows
the user to move the cursor around the text. At some location in the
text, the user performs an edit action, which may be a single keystroke
or a mouse-driven action that deletes or inserts a substring of text. We
send the user-edited text to an automatic formatting operation that may
cause the text to be further modified. When we get back the formatted
text, we have to decide where to position the cursor so that the user
isn't surprised.

If that sounds like a fuzzy problem statement, it's because the
problem is inherently fuzzy. To ask where the cursor should be placed
after formatting is to pose a psychological question about user
expectations. There is no hard and fast answer because there are cases
where human observers disagree on cursor placement.

Consider a formatting operation that trims space characters from each end
of the text and reduces internal space sequences to one space each. The
text manipulation is clearly defined, but it's not clear how it should
affect the cursor.

Here is a piece of text prior to formatting, with the cursor surrounded
by spaces:

    'Twas brillig,  and the  slithy ^  toves

Here is the text after formatting, with a provisional cursor placement:

  'Twas brillig, and the slithy^ toves

Is that where the user expects to find the cursor? Perhaps it would feel
more natural to keep the space to the left of the cursor:

  'Twas brillig, and the slithy ^toves

Maybe the cursor should be moved toward whichever non-space character
is closer. What if the cursor is exactly halfway between two non-space
characters? Do we break ties toward the right? Maybe we should always
go right because a predictable interface is desirable.

Because of such ambiguities, there is no definitive strategy for
implementing a cursor maintenance layer on top of text formatting
operations. We are aiming not to eliminate user surprise but to
minimize it.


## Obvious cases are obvious

Sometimes the correct cursor placement is clear to a human observer. If
the cursor is found among spaces at the beginning or end of the text,
it should be placed at the beginning or end of the trimmed text.

Before formatting:

     Did  gyre  and  gimble  ^

After formatting:

  Did gyre and gimble^

If the cursor is next to a non-space character, it should remain next
to that character across the formatting operation.

Before:

   in  the  ^wabe: 

After:

  in the ^wabe:

How do we resolve such cases automatically? Earlier in this article we
tried a very simple strategy and learned that it was ineffective. Let's
see if we can do better with a slightly more elaborate approach.

We can think of the cursor as splitting the text into two parts, the
one to the left and the one to the right. Why not format the two parts
separately? This would handle cursor placement without ambiguity. Before
and after the formatting operation, the cursor is positioned between
the left and right parts.

Here is some text with a cursor:

    All  mim^sy  were  the borogoves,  

Format the left part:

    All  mim  ->  All mim

Format the right part:

  sy  were  the borogoves,    ->  sy were the borogoves,

Concatenate them at the cursor position:

  All mim^sy were the borogoves,

That was easy. Now for the bad news. This approach is unviable because,
in general, it doesn't make sense to format the left and right parts
separately. It is only guaranteed to work with formatting operations
that consider one character at a time, such as capitalization.

Text with cursor, before capitalization:

  And the^ mome

Left and right parts capitalized:

  And the  ->  AND THE

   mome  ->   MOME

Concatenated:

  AND THE^ MOME

As soon as we have an operation that works on a sequence of characters,
it becomes necessary to preserve continuity between the characters on
each side of the cursor.

Here is a case where we want to apply our space-reducing operation:

   raths ^  outgrabe 

Left and right parts formatted separately:

   raths   ->  raths

    outgrabe   ->  outgrabe

Concatenated:

  raths^outgrabe

To deal with this case correctly, we have to be simultaneously aware of
what lies to the left and to the right of the cursor.

One might argue that the text-splitting approach is almost correct. It
only fails to work for spaces surrounding the cursor. After concatenating
the independently formatted left and right parts, we can examine the one
or two characters in the immediate vicinity of the cursor and adjust them
as necessary. That would indeed work for this operation. It doesn't work
in general.

Recall the number-formatting operation that we described earlier. Consider
this input:

  1234^56789

Left and right parts formatted separately:

  1234  ->  1,234

  56789  ->  56,789

Concatenated:

  1,234^56,789

The result is completely wrong. It doesn't help to inspect a few
characters around the cursor. We have to scan the entirety of the text
to format it correctly:

  123456789  ->  123,456,789

And we have to keep the cursor in its original position:

  123,4^56,789

It remains to be seen what "original position" means and how we can
maintain it.


## Commatize and trimify

We will demonstrate various approaches to cursor maintenance using the
two formatting operations that we have already seen.

From now on, we will refer to the numerical formatting operation as
*commatize*. We can define it exactly by means of a Python script:

  def commatize(self, s, cursor=None):
      s = s.replace(',', '')
      start = len(s) % 3 or 3
      groups = [ s[:start] ]
      for i in range(start, len(s), 3):
          groups.append(s[i : i + 3])
      s = ','.join(groups)
      return (s, cursor)

As for the formatting operation that trims and condenses space sequences,
we call it *commatize*. Here it is in Python:

  def trimify(self, s, cursor=None):
      s = s.strip()
      s = re.sub('\s+', ' ', s)
      return (s, cursor)

A test runner and a suite of test cases are provided for each operation
in a GitHub repository. The `Formatter` class in approach_examples.py
has the commatize and trimify methods shown here. There is an equivalent
JavaScript file, approach_examples.js, in which commatize and trimify
are the properties of the `formatter` object.

Here is `commatize` in JavaScript:

  formatter.commatize = function (s, cursor) {
    var start,
        groups,
        i;
    s = s.replace(/,/g, '');
    start = s.length % 3 || 3;
    groups = [ s.substring(0, start) ];
    for (i = start; i < s.length; i += 3) {
      groups.push(s.substring(i, i + 3));
    }
    s = groups.join(',');
    return { text: s, cursor: cursor };
  };

This is the JavaScript version of `trimify`:

  formatter.trimify = function (s, cursor) {
    s = s.replace(/^\s+|\s+$/g, '');
    s = s.replace(/\s+/g, ' ');
    return { text: s, cursor: cursor };
  };

In the rest of this article we show only Python code for the sake of
brevity. The GitHub repository contains equivalent JavaScript for each
code fragment shown here.

The implementations of commatize and trimify each take a cursor argument
and return it as part of a tuple, but do not modify its value. The
objects that own these methods are interchangeable with other objects
that implement the same text formatting operations but have smarter
policies for maintaining cursor position. The test runner can take
any of these objects and evaluate its performance on the formatting
operation alone or on the task of maintaining cursor operation across
the formatting operation.

For each operation, the test runner contains a list of test cases
exemplifying the cursor behavior we expect to see.

The test cases for commatize are the following.

  'commatize': [
      ('2500', 1, '2,500', 1),
      ('12500', 3, '12,500', 4),
      ('5,4990000', 9, '54,990,000', 10),
      (',1,,8,,,', 3, '18', 1),
      ('1,0,0,000', 3, '100,000', 2),
      ('1,0,000', 2, '10,000', 1),
      ('1,,000', 2, '1,000', 1),
      ('1,00', 2, '100', 1),
      ('1234', 1, '1,234', 1),
      ('1,0234', 3, '10,234', 2),
      ('10,00', 4, '1,000', 4)
  ]

  'trimify': [
      ('  hello  ', 8, 'hello', 5),
      ('  hello  ', 1, 'hello', 0),
      ('Hello,  friends.', 7, 'Hello, friends.', 7),
      ('Hello,  friends.', 8, 'Hello, friends.', 7),
      ('  whirled    peas  now  ', 9, 'whirled peas now', 7),
      ('  whirled    peas  now  ', 10, 'whirled peas now', 8),
      ('  whirled    peas  now  ', 11, 'whirled peas now', 8),
      ('  whirled    peas  now  ', 12, 'whirled peas now', 8),
      ('  whirled    peas  now  ', 13, 'whirled peas now', 8),
      ('     ', 3, '', 0)
  ]



## The numerical approach

class NumericalCursorFormatter(Formatter):

    def commatize(self, s, cursor):
        left_digit_count = cursor - s[:cursor].count(',')
        s = Formatter.commatize(self, s)[0]
        if left_digit_count == 0:
            return (s, 0)
        for pos, ch in enumerate(s):
            if ch != ',':
                left_digit_count -= 1
                if left_digit_count == 0:
                    break
        cursor = pos + 1
        return (s, cursor)

    def trimify(self, s, cursor):
        left = s[:cursor]
        left_trimmed = Formatter.trimify(self, left + '|')[0]
        left_whitespace_count = cursor - len(left_trimmed) + 1
        s = Formatter.trimify(self, s)[0]
        cursor = min(len(s), cursor - left_whitespace_count)
        return (s, cursor)


def choose_cursor_char(s):
    used_chars = set(list(s))
    for ch in '|^_#':
        if ch not in used_chars:
            return ch
    for code in range(32, 127):
        ch = chr(code)
        if ch not in used_chars:
            return ch
    return None


## The textual approach

class TextualCursorFormatter(Formatter):

    def commatize(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        groups = []
        group_chars = []
        digit_count = 0
        for ch in reversed(s):
            if ch != ',':
                group_chars.append(ch)
                if ch != cursor_char:
                    digit_count += 1
                    if digit_count == 3:
                        groups.append(''.join(reversed(group_chars)))
                        group_chars = []
                        digit_count = 0
        if group_chars != []:
            groups.append(''.join(reversed(group_chars)))
        s = ','.join(reversed(groups))
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)

    def trimify(self, s, cursor):
        cursor_char = choose_cursor_char(s)
        s = s[:cursor] + cursor_char + s[cursor:]
        s = Formatter.trimify(self, s)[0]
        s = s.replace(' ' + cursor_char + ' ', ' ' + cursor_char)
        if s[0] == cursor_char:
            s = s.replace(cursor_char + ' ', cursor_char)
        elif s[-1] == cursor_char:
            s = s.replace(' ' + cursor_char, cursor_char)
        cursor = s.index(cursor_char)
        s = s.replace(cursor_char, '')
        return (s, cursor)


## The meta approach

class TextWithCursor:

    def __init__(self, text='', cursor=0):
        self.text = text
        self.cursor = cursor

    def read(self, begin, length=1):
        return self.text[begin : begin + length]

    def insert(self, begin, subtext):
        self.text = self.text[:begin] + subtext + self.text[begin:]
        if self.cursor > begin:
            self.cursor += len(subtext)

    def delete(self, begin, length=1):
        self.text = self.text[:begin] + self.text[begin + length : ]
        if self.cursor > begin:
            self.cursor -= min(self.cursor - begin, length)

    def length(self):
        return len(self.text)

    def append(self, subtext):
        self.insert(self.length(), subtext)

    def display(self):
        print(self.text)
        print(self.cursor * ' ' + '↖')


class MetaCursorFormatter:

    def commatize(self, s, cursor):
        t = TextWithCursor(s, cursor)
        digit_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) == ',':
                t.delete(pos)
            elif digit_count < 2:
                digit_count += 1
            elif pos > 0:
                t.insert(pos, ',')
                digit_count = 0
        return (t.text, t.cursor)

    def trimify(self, s, cursor):
        t = TextWithCursor(s, cursor)
        space_count = 0
        for pos in reversed(range(t.length())):
            if t.read(pos) != ' ':
                space_count = 0
            elif space_count == 0:
                space_count = 1
            else:
                t.delete(pos + 1)
        for pos in [ t.length() - 1, 0 ]:
            if t.read(pos) == ' ':
                t.delete(pos)
        return (t.text, t.cursor)


## The retrospective approach

def levenshtein(s, t):
    n, m = len(s), len(t)
    if min(n, m) == 0:
        return max(n, m)
    current = list(range(m + 1))
    previous = (m + 1) * [ None ]
    for i in range(1, n + 1):
        current, previous = previous, current
        current[0] = previous[0] + 1
        for j in range(1, m + 1):
            if t[j - 1] == s[i - 1]:
                current[j] = previous[j - 1]
            else:
                current[j] = min(previous[j - 1] + 1,
                                 previous[j] + 1,
                                 current[j - 1] + 1)
    return current[m]

def split_levenshtein(s, s_cursor, t, t_cursor):
    cursor_char = choose_cursor_char(s + t)
    left = levenshtein(s[:s_cursor], t[:t_cursor])
    right = levenshtein(s[s_cursor:], t[t_cursor:])
    return left + right


def get_counts(s, chars):
    counts = { ch: 0 for ch in chars }
    for ch in s:
        if ch in chars:
            counts[ch] += 1
    return counts

def left_right_counts(s, cursor, chars):
    count_left = get_counts(s[:cursor], chars)
    count_right = get_counts(s[cursor:], chars)
    return count_left, count_right

def balance_frequencies(s, s_cursor, t, t_cursor):
    chars = set(list(s)).intersection(set(list(t)))
    s_count_left, s_count_right = left_right_counts(s, s_cursor, chars)
    t_count_left, t_count_right = left_right_counts(t, t_cursor, chars)
    cost = 0
    for ch in chars:
        a = 1.0 * s_count_left[ch] / (s_count_left[ch] + s_count_right[ch])
        b = 1.0 * t_count_left[ch] / (t_count_left[ch] + t_count_right[ch])
        cost += abs(a - b) ** 2
    return cost


class RetrospectiveCursorFormatter(Formatter):

    def __init__(self, get_distance):
        self.get_distance = get_distance

    def adjust_cursor(self, original, cursor, formatting_method):
        formatted = formatting_method(self, original)[0]
        cursor_char = choose_cursor_char(original + formatted)
        get_distance = self.get_distance
        best_cost = get_distance(original, cursor, formatted, 0)
        best_pos = 0
        #print(original[:cursor] + '^' + original[cursor:])
        #print('  ^%s %d' % (formatted, best_cost))
        for pos in range(1, len(formatted) + 1):
            cost = get_distance(original, cursor, formatted, pos) 
            #print('  %s^%s %f' % (formatted[:pos], formatted[pos:], cost))
            if cost < best_cost:
                best_cost = cost
                best_pos = pos
        return (formatted, best_pos)

    def commatize(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.commatize)

    def trimify(self, original, cursor):
        return self.adjust_cursor(original, cursor, Formatter.trimify)


## Lessons learned


Formatting operations are defined for text alone and don't tell us what
to do with the cursor. In some cases the optimal cursor placement is
a subjective matter. We have to make a policy about cursor positioning
that goes beyond the formatting operation. We have to accept the risk
that in some cases, our choice of cursor position will not agree with
the user's expectations.

We can use an all-purpose strategy to guess at a sensible position
for the cursor after an arbitrary formatting operation. Alternatively,
we can define a precise relationship between cursor placement and text
formatting by prescribing a fixed rule for each formatting operation.

runnable test scripts in Python and JavaScript

practical web implementation in JavaScript

end-user documentation for everything

