# Maintaining cursor position across formatting operations

This article is for developers who are building text input widgets that
process the user's input to show it in a standard format. If you want
to do real-time formatting and update the text in the input field while
the user is editing it, this article is especially for you.

If you are well acquainted with the problem of maintaining cursor position
and you want to get straight to my code, you can see a live demo and
clone my GitHub repository. The documentation on GitHub tells you how to
use the code in your own project. In this article, I analyze the problem
and describe various approaches I explored in the search for a solution.


## Here is the problem

Suppose you're coding an input field that requires the user to enter the
population of a city. The input field automatically formats this number
with commas separating groups of three digits.

For example, if the user enters `112500`, the input field instantly
changes it to `112,500`.

The user has a cursor in the input field, which we'll represent with
^. Here the cursor is at the right end of the input text:

  112,500^

There are seven characters to the left of the cursor, so we say that
the cursor is at position 7.

We have to update the cursor position after formatting the input. The
cursor is currently at the right end of the input field, and we want to
keep it there after formatting the text.

Suppose the user enters a `0`:

  112,5000^

With the newly entered character, the cursor has moved to position 8. The
input field immediately formats the text `112,5000` to `1,125,000`. Now
there are nine characters, so we move the cursor to position 9:

  1,125,000^

The formula for maintaining the cursor at the right end of the input
field is simple: when the text field contains `n` characters, we put
the cursor at position `n`.

Things get complicated when the user places the cursor elsewhere in
the text.

Suppose the user moves the cursor to position 4:

  1,12^5,000

Now the user hits backspace, deleting the `2` and moving the cursor to
position 3:

  1,1^5,000

The input field formats `1,15,000` to `115,000`. Where should we put
the cursor? This is what happens if we keep it at position 3:

  115^,000

The cursor has jumped across the `5` character, which surprises the
user. The user expects the cursor to remain between the `1` and the `5`:

  11^5,000

This is obvious to a human observer. It's less obvious how to compute
a cursor position that matches the user's expectations.

The root of the problem is that our text formatting does not involve the
cursor. Although the cursor is visually displayed in the text, it is not
logically part of the text. It is an interface element that assists the
user with manual text editing by indicating a position in the text. The
automatic text formatting that is performed by the input field operates
on a string, which is a sequence of characters without any representation
of the cursor. After the text has been transformed by formatting, we
have to place the cursor in a position that minimizes user surprise.

In a few cases, the answer is obvious. If the formatting operation leaves
the text unchanged, we leave the cursor position unchanged. If the cursor
is at the leftmost or rightmost position prior to formatting, we place
it respectively leftmost or rightmost after formatting. In other cases,
we have to examine the characters surrounding the cursor before the
formatting operation. We want to place the cursor in a similar context
after formatting.


# The status quo

The task of maintaining cursor position in a dynamically formatted input
field contains so many subtle difficulties that major applications today
sidestep the problem.

When you enter a dollar amount into an ATM, the figure may be dynamically
formatted with commas, but you will certainly be limited to inserting
and deleting digits at the rightmost position in the input field. Not
even the most recent model of ATM with a high-resolution touchscreen
will offer a movable cursor.

Banking applications on the web and on mobile devices typically let you
move a cursor around the input field as you're entering a dollar amount,
but they don't format the value directly in the input field. Instead
they'll display the formatted value in a separate, non-editable text
field.

[screenshot: PC Financial bill payment]

It is prudent to show the user's raw input and the formatted dollar
amount in separate fields in order to prevent ambiguity in a financial
transaction. In less critical applications where users would be happy
to accept a small degree of ambiguity in exchange for a more streamlined
interface, developers are still wary of the cursor maintenance problem.

Microsoft Excel and Google Sheets let you make a spreadsheet cell with
automatic currency formatting, but you are restricted to editing a raw
figure without commas. The formatted dollar amount only appears after
you remove your cursor from the cell by hitting Enter or clicking on
another cell.

[screenshot: Google Sheets data entry]

It would be faster and friendlier if you could insert your cursor directly
into the formatted text and see new formatting applied instantly while
you edit the text. Of course, you wouldn't want the cursor to jump to
an unexpected location while you're editing. An ideal input field would
automagically format the text and maintain the cursor in a reasonable
position.

Other kinds of formatting would also benefit from intelligent
cursor maintenance. Let's say you're editing a large document in
a word processing application. There are currently two spaces after
every period, and you want to execute a formatting operation that will
reduce all of these to one space. However, you don't want to lose your
place in the text. The document gets repaginated as the whitespace is
reduced, and the line you are currently editing can easily end up on a
different page after formatting. Ideally the application would reformat
the document while keeping the cursor position constant with respect to
the non-whitespace content.

[image: hypothetical word processor doing space reduction]

How can we develop input elements that maintain the cursor in a
user-friendly position while applying various kinds of formatting? Is
it necessary to break down the formatting case by case, or is there a
general approach that works for all possible formatting operations?

It turns out that there are viable strategies falling into two camps. You
can write new formatting operations that move the cursor in tandem
with each step of formatting. Alternatively, you can use your existing
formatting operations and move the cursor in such a way that the context
it occupies after formatting resembles its context before formatting.


## Formalities

In this article, I use the phrase *formatting operation* to mean a
programmatic text-transforming process that is applied to a piece of
text provided by the user. Whenever the user modifies the content of
an input field, we have a new piece of text to pass to the formatting
operation. To clarify the distinction between the user action and the
formatting operation, let's go through another example.

Suppose our input field contains the text `12,900`, which is already
formatted correctly. The cursor is currently at position 4:

  12,9^00

The user moves the cursor to position 3:

  12,^900

The text is unchanged, so there is no need for formatting.

Now the user makes a keystroke that enters the character `5`, leaving
the input field in this state:

  12,5^900

The cursor is now at position 4. The user action has changed the text
in the input field to `12,5900`.

The input field detects that it contains new text. It passes the text to
the formatting operation, which returns `125,900`. This gets substituted
into the input field.

Now the input field must choose a cursor position. This is the problem
that I call cursor maintenance.

A problem instance consists of three input values:

- the *user text* is the textual content of the input field before the
formatting operation

- the *user cursor position* is the location of the cursor in the input
field before the formatting operation

- the *formatted text* is the result of applying the formatting operation to
the user text

In the preceding example, the problem instance is the following:

- user text: `12,5900`

- user cursor position: 4

- formatted text: `125,900`

To solve the problem, we must determine one output value:

- the *formatted cursor position* is where we place the cursor in the
input field after the formatting operation

If the formatted text is identical to the user text, the formatted cursor
position must be the same as the user cursor position. In the remaining
cases, there is no definitive way to decide whether the problem has
been solved correctly. This is a fuzzy problem. Our goal is to minimize
user surprise.

To put it another way, we are seeking to maximize our odds of meeting
the user's expectations. Where would the user expect to see the cursor
after the user text has been transformed into the formatted text?

In the example above, position 3 seems to be a reasonable answer. This
would be the effect of moving the cursor to position 3 after the
formatting operation:

  12,5^900  ->  125^,900

Position 4 also seems reasonable:

  12,5^900  ->  125,^900

It isn't clear which of these formatted cursor positions would be
preferred by a majority of users. However, these are clearly the two
best answers. What matters is that we choose one of these rather than a
cursor position that would be less convenient for the user. We also want
to make the choice in a consistent manner. If we decide an ambiguous
case in one way, we should decide likewise in all similar cases.


## Sample formatting operations

In my investigation of cursor maintenance, I ran experiments using
two formatting operations. The first formats positive integers into
comma-separated three-digit groups, as seen in the examples above. I call
this formatting operation `commatize`. I define it with the following
Python function.

```
def commatize(s):             # s consists of digits and commas.
    s = s.replace(',', '')    # Remove all commas.
    start = len(s) % 3 or 3   # Begin with 1, 2, or 3 digits.
    groups = [ s[:start] ]    # Make the first group of digits.
    for i in range(start, len(s), 3):
        groups.append(s[i : i + 3])  # Add three-digit groups.
    s = ','.join(groups)      # Insert commas between groups.
    return s
```

The other formatting operation, `trimify`, removes all space characters
from the beginning and end of the text, and condenses sequences of spaces
elsewhere in the text to one character each.

For example, the input text

  `  how much  wood  could  a   woodchuck  chuck  `

is transformed by `trimify` into:

  `how much wood could a woodchuck chuck`

I define this formatting operation in Python as follows.

```
def trimify(s):     # s consists of spaces and non-space characters.
    s = s.strip()   # Remove spaces from beginning and end.
    s = re.sub('[ ]+', ' ', s)  # Condense other space sequences.
    return s
```


## Testing methodology

Some cursor-maintenance involve rewriting your formatting operations. To
verify that the rewritten version of a formatting operation performs
the same text transformation as the original version, I ran automated
tests on the command line.

I wrote a Python script,
[`approach_examples.py`](https://github.com/michaellaszlo/maintaining-cursor-position/blob/master/approach_examples.py),
and an equivalent JavaScript file,
[`approach_example.js`](https://github.com/michaellaszlo/maintaining-cursor-position/blob/master/approach_examples.js),
to perform automated testing. The repository's
[README](https://github.com/michaellaszlo/maintaining-cursor-position/blob/master/README.md)
contains detailed documentation on using these files.

In addition to verifying the text transformation, the automated
tests helped me to assess the cursor positions computed by various
strategies. Each case in the test suite contains four values,
corresponding to the three inputs and one output of the cursor-maintenance
problem.

Consider this case in the `trimify` test suite:

  ('  whirled    peas  now  ', 11, 'whirled peas now', 8)

The first three values of the tuple constitute a problem instance. The
fourth value is the answer. Before `trimify`, the cursor is at position
11:

  `  whirled  ^  peas  now  `

After `trimify`, the cursor moves to position 8:

  `whirled ^peas now`

According to my automated test suite, that is the answer to this problem
instance.

Is it the optimal answer? Due to the fuzzy nature of the problem,
it's hard to say. What we can say confidently is this: if the cursor
is surrounded by spaces before `trimify`, the cursor should end up
to the immediate left or right of the single space that remains after
`trimify`. In my test suite, it's on the right. Here it's on the left,
in position 7:

  `whirled^ peas now`

The user would be surprised by any answer other than position 7 or
8. We always want to choose one of these two answers, and we want to do
so consistently.

What does consistency mean? In cases where the cursor is surrounded by
spaces before we run `trimify`, we could do the following after `trimify`:

- always move the cursor to the left of the single space that remains

- always move the cursor to the right of the single space that remains

- always move the cursor to whichever side is closer before `trimify`;
in the event of a tie, always move the cursor to the left or to the right

Any one of these would make a consistent pattern of cursor positioning.

In my test suite, I made the arbitrary choice to always place the
cursor to the right of the sole remaining space. I did not attempt to
write a more elaborate test harness that looks for different patterns
of consistency. Instead, I eyeballed the results of automated testing
and followed up with interactive testing.

I made a [web page](http://192.168.0.106/comparison/) that simultaneously
displays the results of six approaches to cursor maintenance. The
`commatize` and `trimify` formatting operations each have their own input
field in which you set the user text and user cursor position. The cell
immediately below the input field displays the formatted text. The cells
further below display the formatted cursor positions computed by various
strategies. Some involve numerical scores which you can view by clicking
on the `scores` button next to the corresponding outputs.


## The numerical approach

If we know exactly how a formatting operation transforms the text,
we may find it convenient to move the cursor by performing ad hoc
calculations. Consider the effect of `commatize`: it inserts and deletes
commas while leaving the digit characters as they are. Thus, the number
of digit characters to the left of the cursor must be the same before
and after the formatting operation. We can use this knowledge to write
a new version of `commatize`:

```
def commatize(self, s, cursor):
    """Position the cursor by counting digits to its left."""
    left_digit_count = cursor - s[:cursor].count(',')
    s = Formatter.commatize(self, s)[0]
    if left_digit_count == 0:
        return (s, 0)
    for pos, ch in enumerate(s):
        if ch != ',':
            left_digit_count -= 1
            if left_digit_count == 0:
                break
    cursor = pos + 1
    return (s, cursor)
```


## The textual approach


## The meta approach


## The retrospective approach


## Recommendations



