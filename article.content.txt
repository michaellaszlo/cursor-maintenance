# Maintaining cursor position across formatting operations

This article is for developers who are building text input widgets that
process the user's input to show it in a standard format. If you want
to do real-time formatting and update the text in the input field while
the user is editing it, this article is especially for you.

If you are well acquainted with the problem of maintaining cursor position
and you want to get straight to my code, you can see a live demo and
clone my GitHub repository. The documentation on GitHub tells you how to
use the code in your own project. In this article, I analyze the problem
and describe various approaches I explored in the search for a solution.


## Here is the problem

Suppose you're coding an input field that requires the user to enter the
population of a city. The input field automatically formats this number
with commas separating groups of three digits.

For example, if the user enters `112500`, the input field immediately
changes it to `112,500`.

The user has a cursor in the input field, which we'll represent with
^. Here the cursor is at the right end of the input text:

  112,500^

There are seven characters to the left of the cursor, so we say that
the cursor is at position 7.

We have to update the cursor position after formatting the input. The
cursor is currently at the right end of the input field, and we want to
keep it there after formatting the text.

Suppose the user enters a `0`:

  112,5000^

With the newly entered character, the cursor has moved to position 8. The
input field immediately formats the text `112,5000` to `1,125,000`. Now
there are nine characters, so we move the cursor to position 9:

  1,125,000^

The formula for maintaining the cursor at the right end of the input
field is simple: when the text field contains `n` characters, we put
the cursor at position `n`.

Things get complicated when the user places the cursor elsewhere in
the text.

Suppose the user moves the cursor to position 4:

  1,12^5,000

Now the user hits backspace, deleting the `2` and moving the cursor to
position 3:

  1,1^5,000

The input field formats `1,15,000` to `115,000`. Where should we put
the cursor? This is what happens if we keep it at position 3:

  115^,000

The cursor has jumped across the `5` character, which is not what the
user intended. The user expects the cursor to remain between the `1`
and the `5`:

  11^5,000

This is obvious to a human observer. It's less obvious how to compute
a cursor position that matches the user's expectations.


## This is why it's difficult

The root of the problem is that our text formatting does not involve
the cursor. Although the cursor is visually displayed in the text,
it is not logically part of the text. It is an interface element that
assists the user with manual text editing by indicating a position in
the text. The automatic text formatting that is performed by the input
field operates on a string, which is a sequence of characters without
any representation of the cursor. After the text has been transformed
by formatting, we have to place the cursor in a position that minimizes
the risk of surprising the user.

In a few cases, the answer is obvious. If the formatting operation leaves
the text unchanged, we leave the cursor position unchanged. If the cursor
is at the leftmost or rightmost position prior to formatting, we place
it respectively leftmost or rightmost after formatting.

In other cases, we have to examine the characters surrounding the cursor
before the formatting operation. We want to place the cursor in a similar
context after formatting. This is the key to minimizing user surprise.

Sometimes there is more than one cursor position that could be considered
optimal. Suppose the input field is in this state:

  1,^500

Now the user types a `2`:

  1,2^500

The text `1,2500` gets formatted to `12,500`. It seems reasonable to
position the cursor like this:

  12,^500

The `2` and the comma are to the left of the cursor, as they were before
the formatting operation.

One can also argue that this cursor position makes sense:

  12^,500

Here the advantage is that if the user types another digit, let's say
a `9`, it appears to the left of the comma and no further formatting
is necessary:

  129^,500

Either choice is justifiable. In developing the input field, what matters
is not the particular choice we make in an ambiguous case but that we
make that choice consistently. Users appreciate predictability. If we
place the cursor on one side of the comma in a given formatting scenario,
we should strive to put it on the same side in all similar circumstances.


# The status quo

The task of maintaining cursor position in a dynamically formatted input
field contains so many subtle difficulties that major applications today
sidestep the problem.

When you enter a dollar amount into an ATM, the figure may be dynamically
formatted with commas, but you will certainly be limited to inserting
and deleting digits at the rightmost position in the input field. Not
even the most recent model of ATM with a high-resolution touchscreen
will offer a movable cursor.

Banking applications on the web and on mobile devices typically let you
move a cursor around the input field as you're entering a dollar amount,
but they don't format the value directly in the input field. Instead
they'll display the formatted value in a separate, non-editable text
field.

[screenshot: PC Financial bill payment]

It is prudent to show the user's raw input and the formatted dollar
amount in separate fields in order to prevent ambiguity in a financial
transaction. In less critical applications where users would be happy
to accept a small degree of ambiguity in exchange for a more streamlined
interface, developers are still wary of the cursor maintenance problem.

Microsoft Excel and Google Sheets let you make a spreadsheet cell with
automatic currency formatting, but you are restricted to editing a raw
figure without commas. The formatted dollar amount only appears after
you remove your cursor from the cell by hitting Enter or clicking on
another cell.

[screenshot: Google Sheets data entry]

It would be faster and friendlier if you could insert your cursor directly
into the formatted text and see new formatting applied instantly while
you edit the text. Of course, you wouldn't want the cursor to jump to an
unexpected location while you're editing. Ideally the input field should
automagically format the text and maintain the cursor in a reasonable
position.

Other kinds of formatting would also benefit from intelligent
cursor maintenance. Let's say you're editing a large document in
a word processing application. There are currently two spaces after
every period, and you want to execute a formatting operation that will
reduce all of these to one space. However, you don't want to lose your
place in the text. The document gets repaginated as the whitespace is
reduced, and the line you are currently editing can easily end up on a
different page after formatting. Ideally the application would reformat
the document while keeping the cursor position constant with respect to
the non-whitespace content.

[image: hypothetical word processor doing space reduction]

How can we develop input elements that maintain the cursor in a
user-friendly position while applying various kinds of formatting? Is
it necessary to break down the formatting case by case, or is there a
general approach that works for all possible formatting operations?

It turns out that there are several viable approaches. You can rewrite
your formatting operations so as to move the cursor in a completely
predictable fashion. Alternatively, you can keep your existing formatting
operations and probabilistically calculate a similar context for the
cursor after formatting.


## A few definitions




## The numerical approach


## The textual approach


## The meta approach


## The retrospective approach


## Recommendations



