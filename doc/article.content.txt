# Maintaining cursor position in same-field formatting

This article is for developers who are building text input elements
that offer manual editing and automatic formatting in the same field. In
other words, you allow the user to edit the text with a movable cursor
and you apply a format to the text in the same field. Whether the format
is applied after every keystroke or after a special user action, you
have to decide where to put the cursor after the text has been formatted.

If you are familiar with cursor maintenance, you may want to go straight
to my live demo or to my source code. In this article, I introduce the
problem of cursor maintenance and describe my quest for a solution.


## The problem

Suppose we're building an input field that expects the user to enter the
population of a city. This field only accepts input from the number keys
and the backspace key. After every keystroke, the input field formats
the text into groups of three digits separated by commas.

For example, if the user types in `1125`, the input field formats it to
`1,125`.

The user has a cursor in the input field, which we'll represent with
^. Here the cursor is at the right end of the input text:

  112,500^

There are seven characters to the left of the cursor, so we say that
the cursor is at position 7.

We have to update the cursor position after the format is applied. If
the cursor is at the right end of the input field before formatting,
we want it to be at the right end after formatting as well.

Suppose the user enters a `0`:

  112,5000^

After this input action, the cursor has moved to position 8. The input
field formats the text `112,5000` to `1,125,000`. Now there are nine
characters, so we move the cursor to position 9:

  1,125,000^

There is a concise formula for maintaining the cursor at the right end
of the input field: if the text field contains `n` characters, we put
the cursor in position `n`.

Things get complicated when the user moves the cursor elsewhere in
the text.

Suppose the user moves the cursor to position 4:

  1,12^5,000

Now the user hits backspace, deleting the `2` and moving the cursor to
position 3:

  1,1^5,000

The input field formats `1,15,000` to `115,000`. Where should we put
the cursor? This is what happens if we keep it in position 3:

  115^,000

The cursor has jumped across the `5` character, which is surprising
and inconvenient. The user expects the cursor to remain between the `1`
and the `5`:

  11^5,000

This is obvious to a human observer. It is much less obvious how to
compute a cursor position that meets the user's expectations.

The root of the problem is that text formatting does not involve the
cursor. Although the cursor is visually displayed in the text, it is not
logically part of the text. It is an interface element that assists the
user with editing by indicating a position in the text. The format is
applied to a sequence of characters without any representation of the
cursor. After the text has been transformed by formatting, we want to
place the cursor in a position that minimizes user surprise.

In a few cases, the answer is obvious. If the format leaves the text
unchanged, we leave the cursor position unchanged. If the cursor is
at the leftmost or rightmost position prior to formatting, we place it
respectively leftmost or rightmost after formatting. In other cases, we
have to examine the characters surrounding the cursor before formatting
and attempt to place it in a similar context after formatting.


# The status quo

When you use an automated teller machine (ATM), you do not have the
luxury of a movable cursor. The most advanced ATMs of 2016 limit you to
inserting and deleting digits at the right end of the input field. Though
equipped with high-resolution touchscreens and speech synthesis modules,
they offer the same user interface for entering dollar amounts as the
ATMs of the 1970s.

Web apps and mobile apps for banking are only slightly more
sophisticated. A banking app may let you move a cursor around the input
field when you're entering a dollar value, but it won't format the value
directly in the input field. Instead it displays the formatted value in
a separate, non-editable text field.

[screenshot: PC Financial bill payment]

Of course, information integrity is paramount in a financial
transaction. Showing the user's raw input and the formatted dollar
amount in separate fields serves to dispel ambiguity. The drawbacks are
redundancy and complexity. In less critical applications, users would
probably be happy to accept a small degree of ambiguity in exchange for
a faster and friendlier interface.

Consider the clunky interface for editing cells in spreadsheet
applications like Google Sheets and Microsoft Excel. You can make a
spreadsheet cell that displays its value in a dollar format, but you
can't edit the formatted amount directly. You are restricted to editing
the raw text behind the format. The formatted dollar amount only appears
after you move to another cell.

[screenshot: Google Sheets data entry]

It would be more convenient to insert your cursor into the formatted text
and edit it directly. The edited text could be reformatted whenever you
hit a special key, but you would remain in the input field and your cursor
position would be maintained even as the text changes around it. For
certain formats, your text could be instantly formatted after every
keystroke and the cursor would be kept in a position where you expect it.

Larger formatting interfaces would also benefit from cursor
maintenance. Let's say you're editing a document of many pages in a word
processing application. Currently there are two spaces after every period,
and you apply a format that reduces all of these to one space. The
document gets repaginated as the whitespace is reduced, so the line
you were editing ends up on a different page after formatting. You have
to hunt through the text to find your place again. In a better world,
the application would reformat the document while keeping the cursor
position constant with respect to the non-whitespace content.

[image: hypothetical word processor doing space reduction]

How can we develop input elements that maintain the cursor in a
user-friendly position while applying various kinds of formatting? Do
we have to break down the formatting case by case, or is there a general
approach that works for every possible format?


## Terminology

In this article, I use the noun *format* to mean a deterministic
text transformation. In mathematical terms, a format is a function on
strings. A *formatter* is a computational process, such as a JavaScript
function, that implements a format.

After the user has edited the text in an input field, we have a new
piece of text to pass to the formatter. Text that has been edited by
the user but not yet formatted is *raw text*. A formatter takes raw text
and returns *formatted text*.

A *cursor maintainer* is a computational process that performs the last
step in the following interface flow:

1. An input field contains formatted text and a movable cursor.

2. The user performs editing actions in the input field and leaves the
cursor in some position in the raw text.

3. The raw text is passed to a formatter, and the resulting formatted
text replaces the raw text in the input field.

4. The cursor maintainer moves the cursor to some position in the
formatted text.

After the last step, we want the user to perceive the cursor position
as unchanged even though the text has changed. To that end, how do we
choose a cursor position in the formatted text? That is the problem of
cursor maintenance.

Let's go through an example with an input field that instantly formats
its text after every editing action. Suppose our input field contains
the formatted text `12,900`. The cursor is at position 4:

  12,9^00

The user moves the cursor to position 3:

  12,^900

The text is unchanged, so there is no need for formatting.

Next, the user enters the character `5`, leaving the input field in
this state:

  12,5^900

The cursor is now at position 4. The user action has changed the content
of the input field to the raw text `12,5900`.

The input field detects that its content has changed. It passes the raw
text to the formatter, which returns `125,900`. This replaces the raw
text in the input field.

Now the input field must choose a cursor position. We are facing the
problem of cursor maintenance.

A problem instance consists of three input values: the raw text, the
cursor position in the raw text, and the formatted text.

To solve the problem, we must determine one output value: the cursor
position in the formatted text.

We'll say *raw cursor position* to mean the position where the user
has left the cursor in the raw text. The position where the input field
places the cursor in the formatted text is the *new cursor position*.

Note that the raw text and raw cursor position are the result of user
actions. The formatted text is the result of applying a format that was
specified for the input field. The new cursor position is not an automatic
by-product of the format, but the outcome of some computational process
that we devise to handle cursor maintenance for the format.

In the preceding example, the problem instance is the following:

- raw text: `12,5900`

- raw cursor position: 4

- formatted text: `125,900`

If the formatted text is identical to the raw text, the new cursor
position must be the same as the raw cursor position. In the remaining
cases, there is no definitive way to decide whether the problem has
been solved correctly. This is a fuzzy problem. Our goal is to minimize
user surprise.

To put it conversely, we aim to maximize the odds of meeting the user's
expectations. Where would the user expect to see the cursor after the
raw text has been transformed into the formatted text?

In the example above, position 3 seems to be a reasonable answer. This
would be the effect of moving the cursor to position 3 after formatting:

  12,5^900  ->  125^,900

Position 4 also seems reasonable:

  12,5^900  ->  125,^900

It isn't clear which of these new cursor positions would be preferred
by a majority of users. However, these are clearly the two best
answers. What matters is that we choose one of these rather than a
less user-friendly cursor position. We also want to make the choice in
a consistent manner. In ambiguous cases that are similar to this one,
we want to make a similar decision each time.


## Real-time versus on-demand formatting

Althought formatting the content of the input field in real time after
every keystroke may seem aesthetically pleasing, it can have unintended
effects. With some formats, real-time formatting makes the input field
unusable.

Consider a format that strips all whitespace from both ends of the
input. If an input field were to apply this format in real time, it
would be impossible to type a space character at the right end of the
text. The input text `Hello, ` would be instantly formatted to `Hello,`,
effectively deleting the space each time the user attempted to type it.

Other formats would be more amenable to real-time formatting, yet
susceptible to destructive formatting. Consider a numerical input field
that automatically strips zero digits from the left end. If you paste in
`0040001`, it gets formatted to `40001`, which seems reasonable. But if
you decide to change this number to `50001`, and you backspace over the
`4`, this is what happens in the input field:

  `0001` -> `1`

Now instead of typing `5` as you had intended, you have to type `5000`
because the input field deleted the leading zeros.

In cases like this, you can still format the text in the same field if
you do so on demand. This means that you delay formatting until the user
clicks a button or hits a special key. At this point, the easiest way of
dealing with the cursor would be to remove it from the input field. The
user would then be required to click inside the input field to reposition
the cursor and resume editing. However, it would be more user-friendly
to automatically move the cursor to a position in the formatted text
where the user expects to find it. Therefore, cursor maintenance is
desirable regardless of whether same-field formatting is done in real
time or on demand.


## Sample formats

In my investigation of cursor maintenance, I ran experiments using
two formats. The first formats positive integers into comma-separated
three-digit groups, as in the examples above. I call this format
`commatize`. I define it with the following JavaScript function.

```
function commatize(s) {                    // s is a string composed of
  var start, groups, i;                    //  digits and commas.
  s = s.replace(/,/g, '');                 // Remove all commas.
  start = s.length % 3 || 3;               // Begin with 1, 2, or 3 digits.
  groups = [ s.substring(0, start) ];      // Make the first group of digits.
  for (i = start; i < s.length; i += 3) {
    groups.push(s.substring(i, i + 3));    // Add three-digit groups.
  }
  s = groups.join(',');                    // Insert commas between groups.
  return s;
};
```

The other format, `trimify`, removes all whitespace from the beginning
of the text, and condenses whitespace sequences elsewhere in the text
into one character each.

For example, the input text

  `  how much  wood  could  a   woodchuck  chuck  `

is transformed by `trimify` into:

  `how much wood could a woodchuck chuck `

I define this format in JavaScript as follows.

```
function trimify(s) {          // s is an arbitrary string.
  s = s.replace(/^\s+/, '');   // Remove whitespace from the beginning.
  s = s.replace(/\s+/g, ' ');  // Condense remaining whitespace sequences
  return s;                    //  to one space each.
};
```


## Testing methodology

Some cursor-maintenance involve rewriting your formats. To verify that
the rewritten version of a format performs the same text transformation
as the original version, I ran automated tests on the command line. The
[batch tester]() is available in a [source repository]() together with
my [implementations of cursor maintenance]() and other code that I will
mention in this article.

In addition to verifying the text transformation, the automated
tests helped me to assess the cursor positions computed by various
strategies. Each case in the test suite contains four values,
corresponding to the three inputs and one output of the cursor-maintenance
problem.

Here is a case in the `trimify` test suite:

  ('  whirled    peas  now  ', 11, 'whirled peas now ', 8)

The first three values of the tuple constitute a problem instance. The
fourth value is a model answer. In this instance, the cursor is initially
at position 11:

  `  whirled  ^  peas  now  `

After `trimify`, the cursor moves to position 8:

  `whirled ^peas now `

That is the correct answer according to this test suite.

Is it the optimal answer? Due to the fuzzy nature of the problem,
it's hard to say. What we can say confidently is that if the cursor
is surrounded by spaces before `trimify`, the cursor should end up
to the immediate left or right of the single space that remains after
`trimify`. In my test suite, it's on the right. Here it's on the left,
in position 7:

  `whirled^ peas now `

The user would be surprised by any answer other than position 7 or
8. We always want to choose one of these two answers, and we want to do
so consistently.

What does consistency mean? In cases where the cursor is surrounded by
spaces before we run `trimify`, we could do the following after `trimify`:

- always move the cursor to the left of the single space that remains

- always move the cursor to the right of the single space that remains

- always move the cursor to whichever side is closer before `trimify`;
in the event of a tie, move the cursor always to the left or always to
the right

Any one of these would make a consistent pattern of cursor positioning.

In my test suite, I made the arbitrary choice to always place the cursor
to the right of the sole remaining space. In order to observe patterns
of consistency, I followed up automated testing on the command line with
web-based interactive testing.

I made a [comparison page](http://192.168.0.106/comparison/) that
simultaneously displays the results of six approaches to cursor
maintenance. The `commatize` and `trimify` formats each have their own
input field in which you set the raw text and raw cursor position. The
cell immediately below the input field displays the formatted text. The
cells further below display the new cursor positions computed by various
strategies. Some involve numerical scores which you can view by clicking
on the `scores` button next to the corresponding outputs. All of the
approaches are explained below.


## Ad hoc solutions

If we know exactly how a format transforms the text, we may see a
convenient way to calculate a new cursor position. Consider the effect
of `commatize`: it inserts and deletes commas while leaving the digit
characters alone. It would be desirable to position the cursor in such
a way that the digits to the left of the cursor remain constant across
formatting. We can use this idea to write a new version of `commatize`:

```
adHoc.commatize = function (s, cursor) {
  var pos, ch, leftDigitCount;
  // Count the digit characters to the left of the cursor.
  leftDigitCount = cursor - count(s.substring(0, cursor), ',');
  // Apply the original commatize function.
  s = commatize(s);
  if (leftDigitCount == 0) {
    return { text: s, cursor: 0 };
  }
  // Count off digit characters.
  for (pos = 0; pos < s.length; ++pos) {
    ch = s.charAt(pos);
    if (ch != ',') {
      if (--leftDigitCount == 0) {
        break;
      }
    }
  }
  // Place the cursor to the right of the counted digits.
  cursor = pos + 1;
  return { text: s, cursor: cursor };
};
```


This function calls the original `commatize` to transform the text. It
performs cursor maintenance with a calculation devised for the particular
qualities of `commatize`.

We can also come up with a special calculation for `trimify`. It stands
to reason that the cursor should move to the left by one unit for each
space character that gets deleted to the left of the cursor. But if the
cursor isn't involved in the format, how do we decide which characters
get deleted to the left of it?

In this case, the space to the left of the cursor is preserved:

  ` Hello, ^world.  `  ->  `Hello, ^world. `

In this case it is removed:

  ` ^Hello, world.  `  ->  `^Hello, world. `

Sometimes all the spaces around the cursor vanish:

  `  ^  Hello, world.  `  ->  `^Hello, world. `

It turns out that we can handle every case with the trick of appending
a non-space character to `s.substring(0, cursor)` before trimifying it:

```
adHoc.trimify = function (s, cursor) {
  var leftTrimmed;
  // Split the string and guard the cursor's position with a non-space.
  leftTrimmed = format.trimify(s.substring(0, cursor) + '|').text;
  s = format.trimify(s).text;
  // The cursor moves to the right end of the trimified substring or the
  //  entire trimified text, whichever is shorter.
  cursor = Math.min(s.length, leftTrimmed.length - 1);
  return { text: s, cursor: cursor };
};
```

This trick works in the sense that it calculates reasonable cursor
positions. The trouble is that it does so in a non-obvious manner.

Ad hoc solutions to cursor maintenance rely on thoroughly understanding
the format. It may be difficult to find the necessary insights, and
there is no guarantee that they will lead to a concise calculation.


## Using a mock cursor

If the problem is that the text and the cursor are separate entities,
perhaps we can solve it by representing the cursor in the text with
a special character. We'll call this character the mock cursor. Any
character that is not already in the text will do. Consider this state:

  49^50,000

The mock cursor could be a caret, `^`, so that the text becomes:

  49^50,000

We can perform cursor maintenance as follows:

- insert the mock cursor at the raw cursor position
- apply a version of the format that accommodates the mock cursor
- record the position of the mock cursor in the formatted text
- remove the mock cursor from the text

The nub of the matter is how to modify the format to work around the
cursor. In rewriting `commatize`, we must contend with the fact that the
mock cursor displaces every comma to its right. Fixing this displacement
is a laborious process. One way to do it is to chop up the text around
the displaced commas and glue the pieces back together.

In my experiment, I chose to scan the characters of the text in reverse,
placing the digit characters into an array and adding a comma after
every third one. This is computationally more efficient than splitting
and gluing substrings, but it requires more code and it does not benefit
from the mock cursor.

With `trimify`, the mock cursor causes less trouble. Applying the original
version of `trimify` results in text containing at most one extraneous
space, always to the immediate left or right of the mock cursor.

If there is a space on each side of the cursor, we delete the one on
the right:

  `Hello, ^ world.`  ->  `Hello, ^world.`

If the mock cursor is the first character and there is a space next to
it, we delete that space:

  `^ Hello, world.`  ->  `^Hello, world.`

The mock cursor works well with `trimify` because it causes localized
formatting errors that are easy to fix.

Using a mock cursor fails to simplify the problem of cursor maintenance in
general. Although it may help with some formats, it is not a systematic
remedy. It defers the problem, requiring ad hoc computations to correct
formatting errors caused by the mock cursor.

Many other cursor-maintenance methods are revealed by closer examination
to be a flavor of ad hoc. For example, it may seem useful to split
the text at the cursor position, independently format the left and
right portions, then glue them back together and tidy up around the
split. This is another idea that superficially adds rigor but devolves
into unspecified computations.


## The meta approach

What if we were to maintain cursor position by closely following the
text transformation required by the format? If we can decompose the text
transformation into small steps and follow the cursor at each step,
we will know exactly where the cursor is positioned in the formatted
text. Representing the cursor with a special character was only a feint
toward this idea because we still transformed the text with ordinary
string operations that didn't track the cursor position.

To maintain the cursor exactly, we must transform the text with
cursor-aware operations. I call this the meta approach because it
systematically manipulates more than text. The idea is to operate on an
object that represents text with a cursor. To do so, we define operations
to insert and delete characters in a text-with-cursor object.

Consider what should happen to the cursor when we insert a character
into the text. If the character is inserted to the right of the cursor,
the cursor position is unchanged. If the character is inserted to the
left, the cursor position decreases by one. We can easily extend the
calculation to inserting a string of characters.

Suppose we have the text "ice" with the cursor at position 3:

  `lemon^`

Inserting "ade" at position 3 causes no change in cursor position:

  `lemon^ade`

Inserting "pink ", a string of 5 characters, at position 0 changes the
cursor to 3 + 5 = 8:

  `pink lemon^ade`

Now consider deletion. If a character is deleted to the right of the
cursor, the cursor doesn't move. If a character is deleted to its
left, the cursor position decreases by one. The calculation remains
straightforward if we want to delete a span of characters lying strictly
to the left or to the right of the cursor.

When we delete a span of characters that includes the cursor, the cursor
moves to the starting point of the deletion.

Suppose we want to delete 10 characters starting from position 2 in this
text-with-cursor object:

  `pi.nk lemon^ad.e`

The cursor is at position 8, which is between 2 and 2 + 10 =
12. Therefore, the deletion moves the cursor to position 2:

  `pi^e`

These insertion and deletion operations suffice to transform any text
`s` into any other text `t`. At the same time, they modify the cursor
position in a predictable and reasonable manner.

We can implement any format in terms of these two text-with-cursor
operations. In theory we don't even have to rewrite our formats. If we
were to replace the basic string operations of a programming language
with our text-with-cursor operations, every format in that language
would automatically perform cursor maintenance.

Have we found a foolproof method of cursor maintenance? Not at all. The
hitch is that the sequence of insertions and deletions that make up a
format can easily lead to inconvenient cursor displacement.

For example, an implementation of `commatize` may very well start by
initializing a new text-with-cursor object and appending characters
one at a time as it scans the input text. Consequently, the new cursor
position is always at the right end of the text.

The meta approach is only likely to result in user-friendly cursor
positions if each format is implemented as a sequence of local changes
to the input text.

Here is my cursor-maintaining implementation of `commatize` using a
`TextWithCursor` class that I wrote for this experiment:

```
meta.commatize = function (s, cursor) {
  var t = new TextWithCursor(s, cursor),
      digitCount = 0,
      pos;
  for (pos = t.length() - 1; pos >= 0; --pos) {
    if (t.read(pos) == ',') {
      t.delete(pos);
    } else if (digitCount == 3) {
      t.insert(pos + 1, ',');
      digitCount = 1;
    } else {
      ++digitCount;
    }
  }
  return t;
};
```

The notion of performing local operations on a text-with-cursor
object lends clarity to the effort of cursor maintenance. However,
it still calls for reimplementation of the format. The developer doing
the reimplementation has to thoroughly understand the format and must
remain conscious of the cursor displacement caused by each insertion
and deletion.


## Retrospective approach with edit distance

So far we have attempted to do cursor maintenance by peering into the
inner workings of formats. Let's see what we can accomplish by restricting
our attention to the three input values of the cursor-maintenance problem:

- raw text
- raw cursor position
- formatted text

To compute a new cursor position, let's try to answer this question:

What position in the formatted text resembles the raw cursor position
in the raw text?

To make it computationally feasible, the resemblance should be a
quantitative measure that somehow agrees with human perception of the
cursor's place in the text. I call this the retrospective approach
because it chooses a cursor position in the formatted text by looking
back at the cursor in the raw text.

One idea for measuring resemblance begins with the observation that
the cursor splits the text into left and right parts. It can be argued
that the left part of the raw text should resemble the left part of the
formatted text, and the right part of the raw text should resemble the
right part of the formatted text.

Maximizing resemblance is the same as minimizing difference. The
difference between two strings can be expressed by their edit distance,
which is the number of elementary operations required to transform one
string into another. One such measure is the Levenshtein distance,
in which each elementary operation is the insertion, deletion, or
replacement of a character.

Suppose the Levenshtein distance is implemented with a JavaScript function
called `levenshtein`. Given the raw text `s` and raw cursor position
`p`, we can assign a score to each position `q` in the formatted text
`t` by computing the following sum and choosing positions that achieve
the lowest scores:

  levenshtein(s.substring(0, p), t.substring(0, q)) +
  levenshtein(s.substring(p), t.substring(q))

I call that the split Levenshtein formula. In my informal testing,
it works fairly well. It usually agrees with the results of the ad hoc
approaches even though it is oblivious to the details of each format.

The weakness of split Levenshtein is that it often computes tied
scores. For example, given the raw text and cursor

  14,^00

with the formatted text

  1,400

the following scores are computed for each new cursor position:

  ^1,400 6
  1^,400 4
  1,^400 2
  1,4^00 2
  1,40^0 3
  1,400^ 5

Whenever there is a tie, I arbitrarily choose the leftmost of the
lowest-scoring positions. In many cases, such as the one shown here,
this turns out to be a poor choice. Here the rightmost among the tied
positions is best. In other cases, it would be better to use the leftmost
tied position or something in the middle. There is no simple tie-breaking
strategy that works consistently.

Another drawback is the computational cost. It takes `O(n^2)` time
to compute the Levenshtein distance for a pair of strings of length
`O(n)`. There are `n` possible cursor positions, so it costs `O(n^3)`
to solve one instance of the cursor-maintenance problem.

Although cubic time isn't a burden for small input fields, it becomes
problematic for document-scale formatting. If the text contains `10^3`
characters, which is about two hundred English words, using split
Levenshtein for cursor maintenance takes time on the order of `10^9`
computational steps.


## Retrospective approach with character ratios

Another way to retroactively evaluate cursor positions is to count
character frequencies on each side of the cursor.

For example, in the state

  `  later, ^ alligator  `

we can observe that the character `l` occurs once to the left of the
cursor and twice to its right.

Let's define a pair of character-frequency functions, `left` and `right`,
that each take a character, a string, and a position. In the situation
above, with

  s = `  later,  alligator  `

  p = 9

we have:

  left('l', s, p) = 1

  right('l', s, p) = 2

Suppose text `s` is transformed by some format into text `t`. If there
is a position `q` in `t` such that

  left('l', t, q) = 1

  right('l', t, q) = 2

we may conjecture that `q` is a good choice of new cursor position with
respect to the character `l`. There may be several such cursor positions,
or there may be none. Then there are the left-right frequencies of
characters other than `l`. How do we achieve a balance among the various
characters?

Given position `p` in the raw text `s`, let us compute the ratio

  a = left(c, s, p) / (left(c, s, p) + right(c, s, p))

for each character `c` that occurs in both `s` and `t`. We'll

Observe that `left(c, s, p) + right(c, s, p)` is always equal to the total
frequency of the character `c` in `s`. By denoting the total frequency as
`count(c, s)`, we can write the formula more concisely:

  a = left(c, s, p) / count(c, s)

Similarly, at each position `q` in the formatted text `t`, we calculate

  b = left(c, t, q) / count(c, t)

for each character `c` that is common to `s` and `t`.

Then we take the square of the absolute difference between `a` and `b`:

  cost(c, q) = abs(a - b) ** 2

The score of position `q` is the sum of the values `cost(c, q)` over all
common characters `c`. We choose the position that achieves the minimum
score. If there are several, we choose the leftmost.

For the formatting instance `14,^00` -> `1,400`, the scores are:

  ^1,400 3
  1^,400 2
  1,^400 1
  1,4^00 0
  1,40^0 0.25
  1,400^ 1

Here the cursor position with the lowest score is indeed optimal.

We'll call this the retrospective approach with character ratios. It
succeeds in some problem instances where the Levenshtein formula fails. In
other cases, the character-ratio formula doesn't work well.

For the formatting instance `14^,00` -> `1,400`, the scores are:

  ^1,400 2
  1^,400 1
  1,^400 2
  1,4^00 1
  1,40^0 1.25
  1,400^ 2

The minimal score is a tie between `1^,400` and `1,4^00`, both of
which score 1 with the character-ratio formula. By comparing these to
the raw state `14^,00`, we can see that `1^,400` scores 1 because the
`4` was previously to the left of the cursor and here is to the right.
Similarly, `1,4^00` scores 1 because the `,` has moved from the right
to the left. The formula doesn't know, as humans do, that it's more
important to keep the digits disposed properly around the cursor.

When it comes to computational cost, the character-ratio formula is
distinctly superior to the Levenshtein-based formula. Given a fixed set
of characters in a text of size `n`, we can count the `left` frequencies
at every position with one scan in `O(n)` time. The rightmost `left`
frequency gives us the `count` value. With a second scan through the
`left` frequencies, we compute the ratio of `left` to `count` at each
position. The overall time complexity is linear with respect to the
length of the text.


## The layer approach

A weakness of the Levenshtein and character-ratio formulas is that
they treat all characters equally, whereas users do not. The way in which
a user discriminates among characters depends on the text format. In
a `commatize`d input field, the user primarily looks at the cursor's
position with respect to the digit characters. It would make sense to
position the cursor among the digits in the text before considering
commas. For `trimify`, the user's primary concern is the cursor's
positioning among non-whitespace characters.

These observations lead to the idea of evaluating cursor positions
relative to text subsequences that we'll call layers. For example,
we could define two layers for `commatize`, the first consisting of
digits and the second consisting of commas. Thus, the text `1,400`
has the following layers:

       text: 1,400
    layer 0: 1 400
    layer 1:  ,

More formally, layers are induced by character sets. We are using the
following character sets for `commatize`:

  character set 0: { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }
  character set 1: { ',' }

The idea of evaluating a cursor position by counting character frequencies
around the cursor can be adapted to the layers induced by character sets.

Let's define a new function `left(C, s, p)` that yields the number of
characters of `s` to the left of `p` that are in `C`. Let's also define
a new function `count(C, s)` that yields the total number of characters
of `s` that are in `C`, noting that `count` is easily expressed using
`left` and the length of `s`.

For a character set `C` and text `s`, we assign a score to position `p`
by computing the ratio:

  left(C, s, p) / count(C, s)

We scan the text layers one by one, in the order of the character
sets. When considering the layer induced by the first character set, C_0,
we seek a position in the formatted text where the score is closest to
the score achieved by the raw cursor position in the raw text. That is
to say, given the target

  a_0  =  left(C_0, s, p) / count(L_0, s)

for character set `C_0` in the raw text `s` at the raw cursor position
`p`, we are looking for the minimum difference

  abs(left(C_0, t, q) / count(C_0, t) - a_0)

over all positions `t` in the formatted text `q`.

If several positions in the formatted text achieve the minimum difference,
these positions must be adjacent because the scoring function increases
monotonically from left to right.

Let's write `[l_0, r_0]` to denote the range of optimal positions
found for character set `C_0` over the entire formatted text. If `l_0`
is equal to `r_0`, we stop looking and return `l_0` as our choice
of cursor position.  Otherwise, we proceed to the next character set,
`C_1`, and seek to break the tie by evaluating the scoring function over
the range `[l_0, r_0]` in the formatted text.

We ignore positions outside the range `[l_0, r_0]` even if they achieve
a closer score in `C_1`. The search in the higher-ranked `C_0` restricts
the range of candidate positions. Thus, the range `[l_1, r_1]` must be
a subrange of (and possibly equal to) `[l_0, r_0]`.

We scan the layers induced by each character set until the candidate
range narrows to a single position or no more character sets remain. If
we run out of character sets, we return the left end of the final range
by default. We can optionally configure the algorithm to return the
right end of the final range.

In sum, the parameters that we supply to the layer approach are a list
of character sets and a one-bit value indicating whether the tie-breaker
should be the left end or right end of the final range.

It is convenient to implement layer scanning with the help of regular
expressions, which offer a concise syntax for specifying character sets,
which are called character classes in the regex world. With the character
sets defined earlier for `commatize`, we can find layer 0 in a given text
by iterating over its characters and testing each one with the regular
expression `/[0-9]/` or, even more concisely, `/\d/`. We can find layer
1 by testing with `/,/`.

Let's use the layer approach to find a new cursor position for the
formatting instance:

  `14^,00` -> `1,400`

We scan layer 0 of the raw text and compute the score at the raw cursor
position. Layer 0 has two characters to the left of position 2 and four
characters overall. Thus, the target ratio for layer 0 is:

  2 / 4 = 0.5

Now we scan layer 0 of the formatted text. The initial candidate range
is `[0, 5]`. We count the layer 0 characters to the left of each cursor
position in the candidate range:

      formatted text:  1 , 4 0 0
             layer 0:  1   4 0 0
     cursor position: 0 1 2 3 4 5
       layer 0 count: 0 1 1 2 3 4

At position 3, the ratio is 2 / 4 = 0.5, which is equal to the target
ratio. No other position achieves this, so we choose 3 as the new cursor
position:

  1,4^00

We have solved this instance of `commatize` successfully. In fact, the
layer approach always keep the cursor positioned consistently among
digits. That's because `commatize` does not delete or insert digits,
making layer 0 equal in the raw text and formatted text.

In fact, we would be better off without layer 1. If we have two candidate
positions after processing layer 0, they must be to the left and right of
a comma. Leaving the decision to layer 1 would result in sometimes going
left and sometimes right. By deleting layer 1 from the configuration
and always going to the left of a comma, we achieve a consistency that
is probably appreciated by most users.

The layer approach has the same time complexity as the retrospective
approach with character frequencies, which uses a very similar scoring
function. In one scan of the text, we count the number of layer characters
to the left of each position. In a second scan of candidate positions,
we compute the position scores. The overall cost is `O(n)` for text of
length `n`.


## Next steps

If you want to implement same-field formatting with cursor maintenance,
which approach should you choose? You can achieve optimal accuracy
by coding an ad hoc solution as long as you have enough time and
knowledge. Among the flavors of ad hoc I have explored, my preference is
for the meta approach because it forms a layer of abstraction over the
cursor calculations. As with every ad hoc approach, using it properly
depends on detailed knowledge of the format.

At the other end of the spectrum is the retrospective approach with
a zero-configuration scoring function. Among these I recommend the
frequency-balancing formula, which positions the cursor correctly much
of the time. I can't do better than that vague assessment. In order to
quantify the accuracy of a cursor-maintenance implementation, I would
have to test it on a corpus of human text-editing actions drawn from a
real-life application, and I would need a human judgment of the acceptable
cursor positions for each formatting instance.

It may not be worthwhile to conduct such a study. I would argue that
the only acceptable cursor-maintenance algorithm is one that places
the cursor consistently and correctly in every instance. If there are
cases in which the cursor jumps to a surprising position, I consider the
input field to be broken. Instead of trying to quantify the inaccuracy
of a cursor-maintenance algorithm, I believe that we should look for
solutions that we can prove to be completely accurate.

In the spectrum of approaches from fully customized to configuration-free,
the layer approach occupies a sweet spot. It can be made completely
accurate for certain formats with a small configuration. This is not to
say that arriving at a good layer configuration is straightforward. It
is necessary to think through configuration choices and how they affect
cursor positioning, especially in edge cases.

We saw in the previous section that reducing the number of layers may
result in more predictable cursor positioning. With other formats, the
contrary may be true. There is always a question of what the last layer
should look like. Should we define a fallback character set that matches
characters that were not matched by earlier layers? Or should we have a
character set that matches all possible characters? We may need extensive
experimentation and case analysis to find a reasonable configuration.

I recommend that you try the layer approach first. Analyze the format
and see if you can decompose it into semantically significant character
sets. Look at situations in which the cursor is positioned where one layer
ends and another begins. These tend to be the trickiest cases. Consider
tie-breaking with a fallback layer to resolve these cases consistently.

You shouldn't be entirely satisfied with your layer configuration until
you can prove that it leads to flawless cursor maintenance. If you can't,
consider using an ad hoc approach such as the meta approach. Also
consider the option of abandoning cursor maintenance. It would be
better to remove the cursor from the input field at formatting time,
or to display the formatted text separately from the input field, than
to have an inconsistently maintained cursor.

My GitHub repository for this project contains implementations of the
layer algorithm and the other approaches described in this article. The
repository includes a comparison page that shows six approaches applied
in parallel to `commatize` and `trimify`. I also have a demo page that
shows more elaborate user interfaces for the meta, retrospective, and
layer approaches. The retrospective and layer demos allow you to specify
a format of your choosing on the web page. You can also specify your
own layer configuration in the layer demo.


