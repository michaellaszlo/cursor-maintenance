# Maintaining cursor position across formatting operations

This article is for developers who are building text input widgets that
process the user's input to show it in a standard format. If you want
to do real-time formatting and update the text in the input field while
the user is editing it, this article is especially for you.

If you are well acquainted with the problem of maintaining cursor position
and you want to get straight to my code, you can see a live demo and
clone my GitHub repository. The documentation on GitHub tells you how to
use the code in your own project. In this article, I analyze the problem
and describe various approaches I explored in the search for a solution.


## Here is the problem

Suppose you're coding an input field that requires the user to enter the
population of a city. The input field automatically formats this number
with commas separating groups of three digits.

For example, if the user enters `112500`, the input field instantly
changes it to `112,500`.

The user has a cursor in the input field, which we'll represent with
^. Here the cursor is at the right end of the input text:

  112,500^

There are seven characters to the left of the cursor, so we say that
the cursor is at position 7.

We have to update the cursor position after formatting the input. The
cursor is currently at the right end of the input field, and we want to
keep it there after formatting the text.

Suppose the user enters a `0`:

  112,5000^

With the newly entered character, the cursor has moved to position 8. The
input field immediately formats the text `112,5000` to `1,125,000`. Now
there are nine characters, so we move the cursor to position 9:

  1,125,000^

There is a concise formula for maintaining the cursor at the right end
of the input field: when the text field contains `n` characters, we put
the cursor at position `n`.

Things get complicated when the user places the cursor elsewhere in
the text.

Suppose the user moves the cursor to position 4:

  1,12^5,000

Now the user hits backspace, deleting the `2` and moving the cursor to
position 3:

  1,1^5,000

The input field formats `1,15,000` to `115,000`. Where should we put
the cursor? This is what happens if we keep it at position 3:

  115^,000

The cursor has jumped across the `5` character, which surprises the
user. The user expects the cursor to remain between the `1` and the `5`:

  11^5,000

This is obvious to a human observer. It's less obvious how to compute
a cursor position that matches the user's expectations.

The root of the problem is that our text formatting does not involve the
cursor. Although the cursor is visually displayed in the text, it is not
logically part of the text. It is an interface element that assists the
user with manual text editing by indicating a position in the text. The
automatic text formatting that is performed by the input field operates
on a string, which is a sequence of characters without any representation
of the cursor. After the text has been transformed by formatting, we
have to place the cursor in a position that minimizes user surprise.

In a few cases, the answer is obvious. If the formatting operation leaves
the text unchanged, we leave the cursor position unchanged. If the cursor
is at the leftmost or rightmost position prior to formatting, we place
it respectively leftmost or rightmost after formatting. In other cases,
we have to examine the characters surrounding the cursor before the
formatting operation. We want to place the cursor in a similar context
after formatting.


# The status quo

Think about the last time you used an automated teller machine (ATM). When
you enter a dollar amount into an ATM, there is no movable cursor, not
even on the most recent models with high-resolution touchscreens. You
are limited to inserting and deleting digits at the right end of the
input field.

Look at banking applications on the web and on mobile devices. Many
will let you move a cursor around the input field when you're entering
a dollar amount, but they don't format the value directly in the input
field. Instead they'll display the formatted value in a separate,
non-editable text field.

[screenshot: PC Financial bill payment]

Granted, accurate information is paramount in a financial
transaction. Showing the user's raw input and the formatted dollar
amount in separate fields serves to dispel ambiguity. The drawbacks are
redundancy and complexity. In less critical applications, users would
probably be happy to accept a small degree of ambiguity in exchange for
a faster and friendlier interface.

Consider the clunky interface for editing cells in Microsoft Excel
and Google Sheets. You can make a spreadsheet cell that displays its
value with currency formatting, but you can't edit the displayed value
directly. You are restricted to editing an unformatted integer. The
formatted dollar amount only appears after you remove your cursor from
the cell by hitting Enter or clicking on another cell.

[screenshot: Google Sheets data entry]

It would be more convenient to insert your cursor directly into the
formatted text and see new formatting applied instantly while you
edit the text. Of course, you wouldn't want the cursor to jump to an
unexpected position in the text while you're editing it. An ideal input
field would format the text and automagically maintain the cursor in a
convenient position.

Other kinds of formatting would also benefit from cursor
maintenance. Let's say you're editing a large document in a word
processing application. There are currently two spaces after every
period, and you execute a formatting operation that reduces all of
these to one space. The document gets repaginated as the whitespace
is reduced, so the line you were editing ends up on a different page
after formatting. You have to hunt through the text to find your place
again. Ideally the application would reformat the document while keeping
the cursor position constant with respect to the non-whitespace content.

[image: hypothetical word processor doing space reduction]

How can we develop input elements that maintain the cursor in a
user-friendly position while applying various kinds of formatting? Should
we break down the formatting case by case, or is there a general approach
that works for all possible formatting operations?


## Defining the problem

In this article, I use the phrase *formatting operation* to mean a
programmatic text-transforming process that is applied to a piece of
text provided by the user. Whenever the user modifies the content of
an input field, we have a new piece of text to pass to the formatting
operation. To clarify the distinction between the user action and the
formatting operation, let's go through another example.

Suppose our input field contains the text `12,900`, which is already
formatted correctly. The cursor is currently at position 4:

  12,9^00

The user moves the cursor to position 3:

  12,^900

The text is unchanged, so there is no need for formatting.

Now the user makes a keystroke that enters the character `5`, leaving
the input field in this state:

  12,5^900

The cursor is now at position 4. The user action has changed the text
in the input field to `12,5900`.

The input field detects that it contains new text. It passes the text to
the formatting operation, which returns `125,900`. This gets substituted
into the input field.

Now the input field must choose a cursor position. This is the problem
that I call cursor maintenance.

A problem instance consists of three input values:

- the *user text* is the textual content of the input field before the
formatting operation

- the *user cursor position* is the location of the cursor in the input
field before the formatting operation

- the *formatted text* is the result of applying the formatting operation to
the user text

In the preceding example, the problem instance is the following:

- user text: `12,5900`

- user cursor position: 4

- formatted text: `125,900`

To solve the problem, we must determine one output value:

- the *formatted cursor position* is where we place the cursor in the
input field after the formatting operation

If the formatted text is identical to the user text, the formatted cursor
position must be the same as the user cursor position. In the remaining
cases, there is no definitive way to decide whether the problem has
been solved correctly. This is a fuzzy problem. Our goal is to minimize
user surprise.

To put it another way, we are seeking to maximize our odds of meeting
the user's expectations. Where would the user expect to see the cursor
after the user text has been transformed into the formatted text?

In the example above, position 3 seems to be a reasonable answer. This
would be the effect of moving the cursor to position 3 after the
formatting operation:

  12,5^900  ->  125^,900

Position 4 also seems reasonable:

  12,5^900  ->  125,^900

It isn't clear which of these formatted cursor positions would be
preferred by a majority of users. However, these are clearly the two
best answers. What matters is that we choose one of these rather than a
cursor position that would be less convenient for the user. We also want
to make the choice in a consistent manner. If we decide an ambiguous
case in one way, we should decide likewise in all similar cases.


## Sample formatting operations

In my investigation of cursor maintenance, I ran experiments using
two formatting operations. The first formats positive integers into
comma-separated three-digit groups, as in the examples above. I call
this formatting operation `commatize`. I define it with the following
JavaScript function.

```
function commatize(s) {                    // s is a string composed of
  var start, groups, i;                    //  digits and commas.
  s = s.replace(/,/g, '');                 // Remove all commas.
  start = s.length % 3 || 3;               // Begin with 1, 2, or 3 digits.
  groups = [ s.substring(0, start) ];      // Make the first group of digits.
  for (i = start; i < s.length; i += 3) {
    groups.push(s.substring(i, i + 3));    // Add three-digit groups.
  }
  s = groups.join(',');                    // Insert commas between groups.
  return s;
};
```

The other formatting operation, `trimify`, removes all whitespace from
the beginning of the text, and condenses whitespace sequences elsewhere
in the text to one character each.

For example, the input text

  `  how much  wood  could  a   woodchuck  chuck  `

is transformed by `trimify` into:

  `how much wood could a woodchuck chuck `

I define this formatting operation in JavaScript as follows.

```
function trimify(s) {          // s is an arbitrary string.
  s = s.replace(/^\s+/, '');   // Remove whitespace from the beginning.
  s = s.replace(/\s+/g, ' ');  // Condense remaining whitespace sequences
  return s;                    //  to one space each.
};
```


## Testing methodology

Some cursor-maintenance involve rewriting your formatting operations. To
verify that the rewritten version of a formatting operation performs
the same text transformation as the original version, I ran automated
tests on the command line. The [batch tester]() is available in a [source
repository]() together with my [implementations of cursor maintenance]()
and other code that I will mention in this article.

In addition to verifying the text transformation, the automated
tests helped me to assess the cursor positions computed by various
strategies. Each case in the test suite contains four values,
corresponding to the three inputs and one output of the cursor-maintenance
problem.

Here is a case in the `trimify` test suite:

  ('  whirled    peas  now  ', 11, 'whirled peas now ', 8)

The first three values of the tuple constitute a problem instance. The
fourth value is a model answer. In this instance, the cursor is initially
at position 11:

  `  whirled  ^  peas  now  `

After `trimify`, the cursor moves to position 8:

  `whirled ^peas now `

That is the correct answer according to this test suite.

Is it the optimal answer? Due to the fuzzy nature of the problem,
it's hard to say. What we can say confidently is that if the cursor
is surrounded by spaces before `trimify`, the cursor should end up
to the immediate left or right of the single space that remains after
`trimify`. In my test suite, it's on the right. Here it's on the left,
in position 7:

  `whirled^ peas now `

The user would be surprised by any answer other than position 7 or
8. We always want to choose one of these two answers, and we want to do
so consistently.

What does consistency mean? In cases where the cursor is surrounded by
spaces before we run `trimify`, we could do the following after `trimify`:

- always move the cursor to the left of the single space that remains

- always move the cursor to the right of the single space that remains

- always move the cursor to whichever side is closer before `trimify`;
in the event of a tie, move the cursor always to the left or always to
the right

Any one of these would make a consistent pattern of cursor positioning.

In my test suite, I made the arbitrary choice to always place the cursor
to the right of the sole remaining space. In order to observe patterns
of consistency, I followed up automated testing on the command line with
web-based interactive testing.

I made a [comparison page](http://192.168.0.106/comparison/) that
simultaneously displays the results of six approaches to cursor
maintenance. The `commatize` and `trimify` formatting operations each
have their own input field in which you set the user text and user
cursor position. The cell immediately below the input field displays
the formatted text. The cells further below display the formatted cursor
positions computed by various strategies. Some involve numerical scores
which you can view by clicking on the `scores` button next to the
corresponding outputs. All of the approaches are explained below.


## The ad hoc approach

If we know exactly how a formatting operation transforms the text, we
may see a convenient way to calculate a new cursor position. Consider
the effect of `commatize`: it inserts and deletes commas while leaving
the digit characters alone. It would be desirable to position the cursor
in such a way that the digits to the left of the cursor remain constant
across the formatting operation. We can use this idea to write a new
version of `commatize`:

```
adHoc.commatize = function (s, cursor) {
  var pos, ch, leftDigitCount;
  // Count the digit characters to the left of the cursor.
  leftDigitCount = cursor - count(s.substring(0, cursor), ',');
  // Apply the original commatize function.
  s = commatize(s);
  if (leftDigitCount == 0) {
    return { text: s, cursor: 0 };
  }
  // Count off digit characters.
  for (pos = 0; pos < s.length; ++pos) {
    ch = s.charAt(pos);
    if (ch != ',') {
      if (--leftDigitCount == 0) {
        break;
      }
    }
  }
  // Place the cursor to the right of the counted digits.
  cursor = pos + 1;
  return { text: s, cursor: cursor };
};
```


This function calls the original `commatize` to transform the text. It
performs cursor maintenance with a calculation devised for the particular
qualities of `commatize`.

We can also come up with a special calculation for `trimify`. It stands
to reason that the cursor should move to the left by one unit for each
space character that gets deleted to the left of the cursor. But if
the cursor isn't involved in the formatting operation, how do we decide
which characters get deleted to the left of it?

We can't just look at `trimify(s[:cursor])` because the spaces to the
immediate left of the cursor may nor may not appear in the formatted text.

In this case, the space to the left of the cursor is preserved:

  ` Hello, ^world.  `  ->  `Hello, ^world. `

In this case it is removed:

  ` ^Hello, world.  `  ->  `^Hello, world. `

Sometimes all the spaces around the cursor vanish:

  `  ^  Hello, world. ^ `  ->  `^Hello, world.`

It turns out that we can handle every case with the trick of appending
a non-space character to `s[:cursor]` before trimifying it:

```
adHoc.trimify = function (s, cursor) {
  var leftTrimmed;
  // Split the string and guard the cursor's position with a non-space.
  leftTrimmed = format.trimify(s.substring(0, cursor) + '|').text;
  s = format.trimify(s).text;
  // The cursor moves to the right end of the trimified substring or the
  //  entire trimified text, whichever is shorter.
  cursor = Math.min(s.length, leftTrimmed.length - 1);
  return { text: s, cursor: cursor };
};
```

This trickery works in the sense that it calculates reasonable cursor
positions. The trouble is that it does so in a non-obvious manner.

Ad hoc solutions to cursor maintenance rely on thoroughly understanding
the formatting operation. It may be difficult to find the necessary
insights, and there is no guarantee that they will lead to a concise
calculation.


## The mock cursor

If the problem is that the text and the cursor are separate entities,
perhaps we can solve it by representing the cursor in the text with
a special character. We'll call this character the mock cursor. Any
character that is not already in the text will do. Consider this state:

  49^50,000

The mock cursor could be a caret, `^`, so that the text becomes:

  49^50,000

We can perform cursor maintenance as follows:

- insert the mock cursor at the user cursor position
- apply a version of the formatting operation that accommodates the mock cursor
- record the position of the mock cursor in the formatted text
- remove the mock cursor from the text

The burning question is how to modify the formatting operation to work
around the cursor. In rewriting `commatize`, we must contend with the
fact that the mock cursor displaces every comma to its right. Fixing
this displacement is a laborious process. One way to do it is to chop
up the text around the displaced commas and glue them back together.

In my experiment, I chose to scan the characters of the text in reverse,
placing the digit characters into an array and adding a comma after
every third one. This is computationally more efficient than splitting
and gluing substrings, but it requires more code and it does not benefit
from the mock cursor.

With `trimify`, the mock cursor causes less trouble. Applying the original
version of `trimify` results in text containing at most one extraneous
space, always to the immediate left or right of the mock cursor.

If there is a space on each side of the cursor, we delete the one on
the right:

  `Hello, ^ world.`  ->  `Hello, ^world.`

If the mock cursor is the first character and there is a space next to
it, we delete that space:

  `^ Hello, world.`  ->  `^Hello, world.`

The mock cursor works well with `trimify` because it causes localized
formatting errors that are easy to fix.

Using a mock cursor fails to simplify the problem of cursor maintenance
in general. Although it may help with some formatting operations, it
is not a systematic remedy. It defers the problem, requiring ad hoc
computations to correct formatting errors caused by the mock cursor.

Many other cursor-maintenance gimmicks are variations of the ad
hoc approach in disguise. For example, it may seem useful to split
the text at the cursor position, independently format the left and
right portions, then glue them back together and tidy up around the
split. This is another idea that superficially adds rigor but devolves
into unspecified computations.


## The meta approach

A systematic approach to cursor maintenance requires that we specify
what happens to the cursor as the text is transformed. Representing
the cursor with a special character was only a feint toward this idea
because we still transformed the text with ordinary string operations
that didn't track the cursor position.

To maintain the cursor exactly, we must transform the text with
cursor-aware operations. I call this the meta approach because it
systematically manipulates more than text. We are now operating an object
that represents text with a cursor. Let us define operations to insert
and delete characters in a text-with-cursor object.

Consider what should happen to the cursor when we insert a character
into the text. If the character is inserted to the right of the cursor,
the cursor position is unchanged. If the character is inserted to the
left, the cursor position decreases by one. We can easily extend the
calculation to inserting a string of characters.

Suppose we have the text "ice" with the cursor at position 3:

  `lemon^`

Inserting "ade" at position 3 causes no change in cursor position:

  `lemon^ade`

Inserting "pink ", a string of 5 characters, at position 0 changes the
cursor to 3 + 5 = 8:

  `pink lemon^ade`

Now consider deletion. If a character is deleted to the right of the
cursor, the cursor doesn't move. If a character is deleted to its
left, the cursor position decreases by one. The calculation remains
straightforward if we want to delete a span of characters lying strictly
to the left or to the right of the cursor.

When we delete a span of characters that includes the cursor, the cursor
moves to the starting point of the deletion.

Suppose we want to delete 10 characters starting from position 2 in this
text-with-cursor object:

  `pi.nk lemon^ad.e`

The cursor is at position 8, which is between 2 and 2 + 10 =
12. Therefore, the deletion moves the cursor to position 2:

  `pi^e`

These insertion and deletion operations suffice to transform any text
`s` into any other text `t`. At the same time, they modify the cursor
position in a predictable and reasonable manner.

We can implement any formatting operation in terms of these two
text-with-cursor operations. In theory we don't even have to rewrite our
formatting operations. If we were to replace the basic string operations
of a programming language with our text-with-cursor operations, every
formatting operation in that language would automatically perform cursor
maintenance.

Have we found a foolproof method of cursor maintenance? Not at all. The
hitch is that the sequence of insertions and deletions that make up a
formatting operation can easily lead to inconvenient cursor displacement.

For example, an implementation of `commatize` may very well start by
initializing a new text-with-cursor object and appending characters one
at a time as it scans the input text. The outcome is that the formatted
cursor position is always at the right end of the text.

The meta approach is only likely to result in user-friendly cursor
positions if each formatting operation is implemented as a sequence of
local changes to the input text.

Here is my cursor-maintaining implementation of `commatize` using a
`TextWithCursor` class that I wrote for this experiment:

```
meta.commatize = function (s, cursor) {
  var t = new TextWithCursor(s, cursor),
      digitCount = 0,
      pos;
  for (pos = t.length() - 1; pos >= 0; --pos) {
    if (t.read(pos) == ',') {
      t.delete(pos);
    } else if (digitCount == 3) {
      t.insert(pos + 1, ',');
      digitCount = 1;
    } else {
      ++digitCount;
    }
  }
  return t;
};
```

The notion of performing local operations on a text-with-cursor object
lends clarity to the effort of cursor maintenance. However, it still
calls for the reimplementation of formatting operations. The developer
doing the reimplementation has to thoroughly understand each formatting
operation and must remain conscious of the cursor displacement caused
by each insertion and deletion.


## Retrospective approach with edit distance

So far we have attempted to do cursor maintenance by peering into
the inner workings of formatting operations. Let's see what we can
accomplish by restricting our attention to the three input values of
the cursor-maintenance problem:

- user text
- user cursor position
- formatted text

To compute a formatted cursor position, let's try to answer this question:

What position in the formatted text resembles the user cursor position
in the user text?

To make it computationally feasible, the resemblance should be a
quantitative measure that somehow agrees with human perception of the
cursor's place in the text. I call this the retrospective approach
because it chooses a cursor position in the formatted text by looking
back at the cursor in the user text.

One idea for measuring resemblance begins with the observation that the
cursor splits the text into left and right parts. It can be argued that
the left part of the old text should be similar to the left part of the
new text, and the old right part should be similar to the new right part.

The similarity of two strings can be expressed by their edit distance,
which is the number of elementary operations required to transform one
string into another. One such measure is the Levenshtein distance,
in which each elementary operation is the insertion, deletion, or
replacement of a character.

Suppose the Levenshtein distance is implemented with a function called
`levenshtein`, as in my experimental code. Given the user text `s` and
user cursor position `p`, we can assign a score to each position `q`
in the formatted text `t` by computing the following sum and choosing
positions that achieve the lowest scores:

  levenshtein(s[:p], t[:q]) + levenshtein(s[p:], t[q:])

I call that the split Levenshtein formula. In my informal testing,
it works fairly well. It usually agrees with the results of the ad hoc
approaches even though it is oblivious to the details of each formatting
operation.

The weakness of split Levenshtein is that it often computes tied
scores. For example, given the user text and cursor

  14^,00

with the formatted text

  1,400

the following scores are computed for each formatted cursor position:

  ^1,400 4
  1^,400 2
  1,^400 2
  1,4^00 2
  1,40^0 4
  1,400^ 6

Whenever there is a tie, I arbitrarily choose the leftmost of the
lowest-scoring positions. In many cases, such as the one shown here, this
turns out to be a poor choice. Here the rightmost among the tied positions
is best. In other cases, the average of the tied positions is visually
optimal. There is no simple tie-breaking strategy that works consistently.

Another drawback is the computational cost. It takes `O(n^2)` time
to compute the Levenshtein distance for a pair of strings of length
`O(n)`. There are `n` possible cursor positions, so it costs `O(n^3)`
to solve one instance of the cursor-maintenance problem.

Although cubic time isn't a burden for small input fields, it becomes
problematic for document-scale formatting. If the text contains `10^3`
characters, which is about two hundred English words, using split
Levenshtein for cursor maintenance takes time on the order of `10^9`
computational steps.


## Retrospective approach with character frequencies

Another way to retroactively evaluate cursor positions is to count
character frequencies on each side of the cursor.

For example, in the state

  `  Hello, ^ world.  `

we can observe that the character `l` occurs twice to the left of the
cursor and once to its right.

Let's define a pair of character-frequency functions, `left` and
`right`, that each take a string, a position, and a character. In
the situation above, with

  s = `  Hello,  world.  `

  p = 10

we have:

  left(s, p, 'l') = 2

  right(s, p, 'l') = 1

Suppose the text `s` is transformed by some formatting operation into
the text `t`. If there is a position `q` in `t` such that

  left(t, q, 'l') = 2

  right(t, q, 'l') = 1

we can say that `q` is a good choice of formatted cursor position with
respect to the character `l`. There may be several such cursor positions,
or there may be none. Then there are the left-right frequencies of
characters other than `l`. How do we achieve a balance among the various
characters?

I propose that we compute the ratio

  a = left(s, p, c) / (left(s, p, c) + right(s, p, c))

for each character `c` that occurs in both `s` and `t`. Likewise,
we compute

  b = left(t, q, c) / (left(t, q, c) + right(t, q, c))

for each position `q` in `t`.

Then we take the square of the absolute difference:

  cost(q, c) = abs(a - b) ** 2

The score of position `q` is the sum of the values `cost(q, c)` over all
characters `c` that occur in both `s` and `t`. We choose the position that
achieves the minimum score. If there are several, we choose the leftmost.

In my testing, I have found that this scoring formula works approximately
as well as the one using the Levenshtein distance. This is a subjective
impression. In order to quantify the accuracy of each approach, I would
have to assemble a significant corpus of problem instances along with
a gold standard for judging formatted cursor positions.

The character-frequency formula is advantageous in terms of computational
cost. Given a fixed set of characters in a text of size `n`, we can count
the `left` frequencies at every position with one scan in `O(n)` time.

The value of `left` at position `n` gives us the value of `right` at
position `0`. Furthermore, this value is the sum of `left` and `right`
at every position. With a second scan through the `left` frequencies,
we can compute the remaining values of `right` in `O(n)` time. This
means that the cost of computing the left-right ratios for all cursor
positions is within a constant factor of the length of the text.


## The layer approach

Our retrospective scoring formulas treat all characters equally. Humans
do not. In a `commatize`d input field, for example, we are primarily
interested in the cursor's position with respect to the digit
characters. In `trimify`, we are mostly concerned with the cursor's
positioning among the non-space characters of the text.

Why not employ a strategy that recognizes the semantic differences
between different classes of characters? Let's define a layer by means
of a boolean function that takes a character and return true iff the
character belongs to the layer.

Consider this state:

  1^00,900

The user enters a `0`:

  10^00,900

The text `1000,900` is formatted to `1,000,900`. The user expects to
see this:

  1,0^00,900

According to retrospection with character frequencies, the optimum result
is this:

  1^,000,900

The comma ratio around the cursor was 0:1 in the user text. Because the
retrospective formula does not discriminate between commas and digits,
the the 0:2 comma ratio in the formatted text outweighs the digit ratio.


## Summary

I haven't found a fully satisfying approach to the problem of
cursor maintenance. The most accurate solutions depend on a thorough
understanding of the formatting operations and require the most code to
implement. The one-size-fits-all solutions can be added to an input field
with little effort, but will occasionally move the cursor to surprising
positions. You must choose your approach based on what resources are at
your disposal and what you hope to achieve.

Can you avoid cursor maintenance altogether? If you have an input field
with a movable cursor and if the field formats its contents in real time
after each user action, you should try to find a user-friendly cursor
position in the formatted text. In my opinion, failing to do so degrades
the user experience to an unacceptable degree. If you do not want to
attempt cursor maintenance, I recommend that you avoid real-time input
formatting. It would be better to redesign the interface by, for example,
keeping the unformatted text in the input field while displaying the
formatted text in a non-editable text area.

If you do want to perform real-time formatting with cursor maintenance,
I advise against the ad hoc approach. It can be tempting to calculate
cursor positions without a systematic approach, but doing so exposes you
to a wide range of logical errors. An ad hoc computation is suitable
only if you understand the formatting operation completely and you
see exactly how to calculate formatted cursor positions. Otherwise,
I recommend that you employ one of the other approaches.

The mock cursor is a trick that lets you format most of the text as usual,
followed by an ad hoc clean-up around the cursor position. It is a good
trick if the formatting errors caused by the mock cursor are localized
and you see a good way to fix the local formatting errors. This may be
an attractive solution to formatting a large document.

The meta approach causes minimal cursor displacement if you reimplement
each formatting operation with local operations on a text-with-cursor
object. This is the best approach, I feel, if you have the leisure to
meticulously reimplement the formatting operations.

When development time and computational resources are in short supply,
you may want to apply the retrospective approach with balanced character
frequencies. It requires minimal work to implement and it runs in linear
time. However, you must be aware that it is liable to compute surprising
cursor positions. You have to consider the application and ask yourself
whether your users will tolerate odd cursor movements.

My [approach-comparison page]() shows the kinds of discrepancies you
can expect. I made that page for experimental purposes.

I made a more polished [demonstration page]() that shows two approaches
in action. The meta approach is used for `commatize` and the retrospective
frequency-balancing approach is used for `trimify`.

If you want to see how well the retrospective approach works for your
own formatting operation, go ahead and [replace `trimify`]() with any
function that takes a string argument and returns a string result.

